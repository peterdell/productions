;  flashincr.src - The!Cart incremental flasher utility routines
;
;  Copyright (C) 2013-2014 Matthias Reichl <hias@horus.com>
;
;  This program is free software; you can redistribute it and/or modify
;  it under the terms of the GNU General Public License as published by
;  the Free Software Foundation; either version 2 of the License, or
;  (at your option) any later version.
;
;  This program is distributed in the hope that it will be useful,
;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;  GNU General Public License for more details.
;
;  You should have received a copy of the GNU General Public License
;  along with this program; if not, write to the Free Software
;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

; calcluate flash address from BLOCKNO
SETUPBLOCKFADR
	LDA #0
	STA BLOCKFADR
	STA BLOCKFADR+1
	LDA BLOCKNO
	ASL
	STA BLOCKFADR+2
	LDA BLOCKNO+1
	ROL
	STA BLOCKFADR+3
	RTS

; setup addresses for accessing block BLOCKNO
SETUPBLOCK
	JSR SETUPBLOCKFADR

; checksum offset (*256, /4 instead of *64)
	LDA #0
	STA BLOCKCSADR
	STA BLOCKCSADR+3
	LDA BLOCKNO
	STA BLOCKCSADR+1
	LDA BLOCKNO+1
	STA BLOCKCSADR+2
	LSR BLOCKCSADR+2
	ROR BLOCKCSADR+1
	ROR BLOCKCSADR
	LSR BLOCKCSADR+2
	ROR BLOCKCSADR+1
	ROR BLOCKCSADR
	ADD4 BLOCKCSADR, CSUMADR, BLOCKCSADR

; block usage bitmap
	LDA BLOCKNO
	ASL
	STA FLASHTMP
	LDA BLOCKNO+1
	ROL
	STA FLASHTMP+1
	ADD2I FLASHTMP, IMAGEMAP, FLASHTMP
	LDY #0
	LDA (FLASHTMP),Y
	STA BLOCKMAP
	INY
	LDA (FLASHTMP),Y
	STA BLOCKMAP+1

	RTS

; convert block-number to bank-number
MULTBLOCKBANK
	ASL BLOCKBANK
	ROL BLOCKBANK+1
	ASL BLOCKBANK
	ROL BLOCKBANK+1
	ASL BLOCKBANK
	ROL BLOCKBANK+1
	ASL BLOCKBANK
	ROL BLOCKBANK+1
	RTS

; setup BLOCKBANK and BLOCKDISK from BLOCKNO
SETUPBLOCKBANK
; calculate linear sector number
	LDA DRIVEDNS
	CMP #DRIVEDNS_DD
	BEQ ?SETUPBLOCKBANKDD

	FCOPY2 BLOCKNO, BLOCKBANK
	JSR MULTBLOCKBANK
	LDA #1
	STA BLOCKDISK
	RTS

; calculate image number
?SETUPBLOCKBANKDD
	LDX #1
?SETUPBLOCKBANKDDLP
	TXA
	ASL
	TAY
	LDA BLOCKNO+1
	CMP DDBLOCKNO+1,Y
	BCC ?SETUPBLOCKBANKDD2
	BNE ?SETUPBLOCKBANKDD1
	LDA BLOCKNO
	CMP DDBLOCKNO,Y
	BCC ?SETUPBLOCKBANKDD2
?SETUPBLOCKBANKDD1
	INX
	BNE ?SETUPBLOCKBANKDDLP	; always
?SETUPBLOCKBANKDD2
	STX BLOCKDISK
; substract start of block
	SEC
	LDA BLOCKNO+1
	SBC DDBLOCKNO-1,Y
	STA BLOCKBANK+1
	LDA BLOCKNO
	SBC DDBLOCKNO-2,Y
	STA BLOCKBANK
	JSR MULTBLOCKBANK
	RTS

; display "insert image X in drive Y" and wait for keypress
; returns: C=0 OK, C=1 abort
INSERTIMG
	BPUT0 TINSIMG1
	LDX BLOCKDISK
	LDY #0
	JSR PRDEC
	BPUT0 TINSIMG2
	LDX CURDRIVENO
	LDY #0
	JSR PRDEC
	JSR GETCHAR
	CPY #128
	BEQ ?INSERTIMGX
	LDA #155
	JSR PUTCHAR
	CLC
	RTS
?INSERTIMGX
	JMP RETABORT

; check if the multi-image in CURDRIVENO is valid
; returns: C=0 OK, C=1 error
CHECKMULTI
	LDA CURDRIVENO
	JSR CHKDENS
	BCC ?CHECKMULTI1
	JSR PNODISK
	SEC
	RTS

?CHECKMULTI1
; check if drive density matches
	CMP DRIVEDNS
	BEQ ?CHECKMULTI2
	PRINT0 TUNSUPDNS
	SEC
	RTS

?CHECKMULTI2
; load subsequent header
	JSR LOADHEADER2
	BPL ?CHECKMULTI3
	JSR PREADERR
	SEC
	RTS

?CHECKMULTI3
; check for header signature
	JSR VRFYHEADER
	BCC ?CHECKMULTI4
	PRINT0 TILLPSIG
	SEC
	RTS

?CHECKMULTI4
; check image id
	JSR VRFYIMGID
	BCC ?CHECKMULTI5
	PRINT0 TWRONGIMG
	SEC
	RTS

?CHECKMULTI5
; check image part number
	LDA DATABUF+PHPARTNO
	CMP BLOCKDISK
	BEQ ?CHECKMULTI6
	PHA
	BPUT0 TWRONGIMGNO
	PLA
	TAX
	LDY #0
	JSR PRDEC
	LDA #155
	JSR PUTCHAR
	SEC
	RTS

?CHECKMULTI6
; image verified, store current disk number
	STA CURDISK
	CLC
	RTS

; prepare for reading a block
; returns: C=0 OK, C=1 abort
PREPAREBLOCK
	JSR SETUPBLOCKBANK
; check if the image part matches current disk
	LDA CURDISK
	CMP BLOCKDISK
	BNE ?PREPAREBLK1
?PREPAREBLKOK
	CLC
	RTS

?PREPAREBLK1
; are we in subsequent image mode?
	LDA SUBSEQUENT
	BNE ?PREPAREBLKSUB

; no, ask the user to insert the disk
?PREPAREBLKLP
	JSR INSERTIMG
	BCC ?PREPAREBLK2
	RTS

?PREPAREBLK2
	JSR CHECKMULTI
	BCS ?PREPAREBLKLP
	RTS

?PREPAREBLKSUB
; calculate drive number
	SEC
	LDA BLOCKDISK
	SBC CURDISK
	CLC
	ADC CURDRIVENO
; drive number valid?
	CMP #MINDRIVENO
	BCC ?PREPAREBLKSUBERR
	CMP #MAXDRIVENO+1
	BCS ?PREPAREBLKSUBERR
; yes, check if image is OK
	STA CURDRIVENO
	JSR CHECKMULTI
	BCS ?PREPAREBLKSUBERR
	RTS

?PREPAREBLKSUBERR
; use initially entered drive number
	LDA DRIVENO
	STA CURDRIVENO
	JMP ?PREPAREBLKLP

; lookup table for BLOCKMAP bits
BMBYTETAB
	.DC 8 0
	.DC 8 1
BMBITTAB
	.BYTE 1,2,4,8,16,32,64,128
	.BYTE 1,2,4,8,16,32,64,128

; setup DAUX and FLASHADR for accessing
; bank BANKNO inside current block
; also sets BNKSTAT
SETUPBANK
; setup BNKSTAT
	LDX BANKNO
	LDY BMBYTETAB,X		; lo/hi byte selection
	LDA BLOCKMAP,Y
	LDY #$C0		; default: has data
	AND BMBITTAB,X		; bit selection
	BNE ?SETUPBSEND
	LDY #$40		; first bank, empty
	CPX #0
	BEQ ?SETUPBSEND
	LDY #0			; non-first bank, empty
?SETUPBSEND
	STY BNKSTAT

; flash address
	LDA #0
	STA FLASHADR
	STA FLASHADR+3

	LDA BANKNO
	ASL
	ASL
	ASL
	ASL
	ASL
	STA FLASHADR+1
	LDA #0
	ROL
	STA FLASHADR+2
	ADD4 FLASHADR, BLOCKFADR, FLASHADR

; sector number
	CLC
	LDA BLOCKBANK
	ADC BANKNO
	STA DAUX1
	LDA BLOCKBANK+1
	ADC #0
	STA DAUX2

	LDA DRIVEDNS
	CMP #DRIVEDNS_DD
	BEQ ?SETUPBANKDD

	ADD2I DAUX1, PISECTOR_8K, DAUX1
	RTS

?SETUPBANKDD
; multiply DAUX with 32
	ASL DAUX1
	ROL DAUX2
	ASL DAUX1
	ROL DAUX2
	ASL DAUX1
	ROL DAUX2
	ASL DAUX1
	ROL DAUX2
	ASL DAUX1
	ROL DAUX2
	ADD2I DAUX1, PISECTOR_DD, DAUX1
	RTS

; check header for signature
; return: C=0 OK, C=1 ERROR
VRFYHEADER
	LDY #0
?VRFYHD1
	LDA DATABUF+PHSIGNATURE,Y
	CMP HDRSIG,Y
	BNE ?VRFYHDE
	INY
	CPY #PHSIGLEN
	BNE ?VRFYHD1
	CLC
	RTS

?VRFYHDE
	SEC
	RTS

; verify image id, used by subsequent headers
; return: C=0 OK, C=1 ERROR
VRFYIMGID
	LDY #0
?VRFYIMGIDLP
	LDA DATABUF+PHIMGID,Y
	CMP IMAGEID,Y
	BEQ ?VRFYIMGID1
	SEC
	RTS

?VRFYIMGID1
	INY
	CPY #IMAGEIDLEN
	BNE ?VRFYIMGIDLP
	CLC
	RTS

; parse header and store information
; return C=1 on error
PARSEHEADER
	JSR VRFYHEADER
	BCC ?PARSEHDR1
	SEC
	RTS
?PARSEHDR1
	LDA DATABUF+PHPARTNO
	CMP #1
	BEQ ?PARSEHDR2
	PRINT0 TNOTPART1
	SEC
	RTS
?PARSEHDR2
	STA CURDISK

; block count
	LDA DATABUF+PHBLOCKCOUNT
	STA IBLOCKCOUNT
	LDA DATABUF+PHBLOCKCOUNT+1
	STA IBLOCKCOUNT+1
; checksum start/count
	LDA DATABUF+PHCSSTART
	STA ICSUMSTART
	LDA DATABUF+PHCSSTART+1
	STA ICSUMSTART+1
	LDA DATABUF+PHCSCOUNT
	STA ICSUMCOUNT

?PARSEHDR3
; calculate checksum address
	LDA #0
	STA CSUMADR
	STA CSUMADR+1
	LDA ICSUMSTART
	ASL
	STA CSUMADR+2
	LDA ICSUMSTART+1
	ROL
	STA CSUMADR+3
	
; copy image id
	LDY #0
?PARSEHDR4
	LDA DATABUF+PHIMGID,Y
	STA IMAGEID,Y
	INY
	CPY #IMAGEIDLEN
	BNE ?PARSEHDR4

; copy usage bitmap
	LDA #<[DATABUF+PHBITMAP]
	STA DATAVEC
	LDA #>[DATABUF+PHBITMAP]
	STA DATAVEC+1
	LDA #<IMAGEMAP
	STA FLASHTMP
	LDA #>IMAGEMAP
	STA FLASHTMP+1
	LDX #>IMAGEMAPLEN
	LDY #0
?PARSEHDR5
	LDA (DATAVEC),Y
	STA (FLASHTMP),Y
	INY
	BNE ?PARSEHDR5
	INC DATAVEC+1
	INC FLASHTMP+1
	DEX
	BNE ?PARSEHDR5

	CLC
	RTS

; check for base flash signature at default location
; return: C=1 if no signature present in flash
; sets up FBLOCKCOUNT if signature found
CHKFLASHSIG_DFL
	LDA #<CINFOSTART
	STA FLASHADR
	LDA #>CINFOSTART
	STA FLASHADR+1
	LDA #<[HASHSTART*2]
	STA FLASHADR+2
	LDA #>[HASHSTART*2]
	STA FLASHADR+3

; check for base signature
	LDA #CSIGLEN
	JMP CHKFLASHSIG_INT

; check for full flash signature at location from programming header
; return: C=1 if no signature present in flash
;         N=1 if no signature present in programming header
; sets up FBLOCKCOUNT if signature found in programming header
CHKFLASHSIG_HDR
	LDA ICSUMCOUNT
	BNE ?CHKFLASHSIG_HDR1
; no signature present in programming header, no checksum block
	LDY #$FF
	SEC
	RTS

?CHKFLASHSIG_HDR1
	LDA ICSUMSTART
	STA BLOCKNO
	LDA ICSUMSTART+1
	STA BLOCKNO+1
	JSR SETUPBLOCKFADR
	LDA #<CINFOSTART
	STA FLASHADR
	LDA #>CINFOSTART
	STA FLASHADR+1
	LDA BLOCKFADR+2
	STA FLASHADR+2
	LDA BLOCKFADR+3
	STA FLASHADR+3

; check for full signature
	LDA #CSIGLEN
	JMP CHKFLASHSIG_INT

; check flash for signature
; in: A = number of bytes to check
; return: C=1 if no signature present
;         N=0 always
CHKFLASHSIG_INT
	PHA
	LDA #0
	STA FBLOCKCOUNT
	STA FBLOCKCOUNT+1

; copy info block to DATABUF
	JSR SETDATABUF

	JSR FENABLE
	LDX #CINFOLEN
	LDY #0
	JSR FRBYTE
	JSR FDISABLE

	PLA
	TAX

; check for signature
	LDY #0
?CHKFSIG1
	LDA DATABUF+CSIGNATURE,Y
	CMP FLASHSIG,Y
	BEQ ?CHKFSIG2
	LDY #0
	SEC
	RTS

?CHKFSIG2
	INY
	DEX
	BNE ?CHKFSIG1

; version number matches, copy number of used flash blocks
	LDA DATABUF+CBLOCKCOUNT
	STA FBLOCKCOUNT
	LDA DATABUF+CBLOCKCOUNT+1
	STA FBLOCKCOUNT+1

	LDY #0
	CLC
	RTS

; compare block checksum
; return C=1 if different
CMPCSUM
	LDA INCREMENTAL
	BMI ?CMPCSUM0
	BNE ?CMPCSUM1
?CMPCSUM0
; no checksum in full and initial incremental modes
	SEC
	RTS
?CMPCSUM1
; compare blockno with blockno from flash
	LDA BLOCKNO+1
	CMP FBLOCKCOUNT+1
	BCC ?CMPCSUM3
	BEQ ?CMPCSUM2
	RTS
?CMPCSUM2
	LDA BLOCKNO
	CMP FBLOCKCOUNT
	BCC ?CMPCSUM3
	RTS

?CMPCSUM3
; block number within limits, compare checksums

; cache valid?
	LDA CSCACHE_VALID
	BEQ ?CMPCSUM5	; no
; check if address matches
	LDA BLOCKCSADR+1
	CMP CSCACHE_ADR
	BNE ?CMPCSUM5
	LDA BLOCKCSADR+2
	CMP CSCACHE_ADR+1
	BNE ?CMPCSUM5
	LDA BLOCKCSADR+3
	CMP CSCACHE_ADR+1
	BNE ?CMPCSUM5

; address matches, compare cached checksum
?CMPCSUM4
	LDX #HASHLEN
	LDY BLOCKCSADR
?CMPCSUM4L
	LDA CSCACHE,Y
	CMP FCSCACHE,Y
	BNE ?CMPCSUM4L1
	INY
	DEX
	BNE ?CMPCSUM4L

; checksum identical
	CLC
	RTS

; checksum mismatch
?CMPCSUM4L1
	SEC
	RTS

?CMPCSUM5
; cache invalid, load data from flash and RAM

; set checksum address in RAM
	SUB4 BLOCKCSADR, CSUMADR, FLASHADR
; clear low-order byte of FLASHADR
	LDA #0
	STA FLASHADR

; load checksum from RAM into CSCACHE
	LDA #<CSCACHE
	STA DATAADR
	LDA #>CSCACHE
	STA DATAADR+1

	JSR MODERAM
	JSR FENABLE
	LDX #1
	JSR FRPAGE
	JSR FDISABLE
	JSR MODEFLASH

; set checksum address in flash
	FCOPY4 BLOCKCSADR, FLASHADR
	LDA #0
	STA FLASHADR

; load checksum from flash into FCSCACHE
	LDA #<FCSCACHE
	STA DATAADR
	LDA #>FCSCACHE
	STA DATAADR+1

	JSR FENABLE
	LDX #1
	JSR FRPAGE
	JSR FDISABLE

; set currently cached address
	LDA BLOCKCSADR+1
	STA CSCACHE_ADR
	LDA BLOCKCSADR+2
	STA CSCACHE_ADR+1
	LDA BLOCKCSADR+3
	STA CSCACHE_ADR+2
	LDA #1
	STA CSCACHE_VALID

; and compare checksum
	JMP ?CMPCSUM4

; old version without cache
.if 0

.if 0
; Hias test: print flash address
	LDA #'f
	JSR PUTCHAR
	JSR PFLADR
	LDA #32
	JSR PUTCHAR
.endif

; compare with flash
	JSR FENABLE
	LDX #HASHLEN
	LDY #0
	JSR FCBYTE
	PHP
	PHA
	JSR FDISABLE
	PLA
	PLP




; set checksum address in RAM
	SUB4 BLOCKCSADR, CSUMADR, FLASHADR
	JSR SETDATABUF

; load checksum from RAM into databuf
	JSR MODERAM
	JSR FENABLE
	LDX #HASHLEN
	LDY #0
	JSR FRBYTE
	JSR FDISABLE
	JSR MODEFLASH

; set checksum address in flash
	FCOPY4 BLOCKCSADR, FLASHADR

.if 0
; Hias test: print flash address
	LDA #'f
	JSR PUTCHAR
	JSR PFLADR
	LDA #32
	JSR PUTCHAR
.endif

; compare with flash
	JSR FENABLE
	LDX #HASHLEN
	LDY #0
	JSR FCBYTE
	PHP
	PHA
	JSR FDISABLE
	PLA
	PLP

.if 0
; Hias test: print equal status
	PHP
	PHP
	PHA
	PHP
	LDA #'e
	PLP
	BEQ ?LOADCSEQU1
	LDA #'n
?LOADCSEQU1
	JSR PUTCHAR
	LDA #32
	JSR PUTCHAR
	LDA #'a
	PLA
	JSR PUTHEX
	LDA #'s
	JSR PUTCHAR
	PLP
	JSR PUTHEX
	JSR GETCHAR
	LDA #155
	JSR PUTCHAR
	PLP
.endif

	BPL ?CMPCSUM4
	SEC
	RTS
?CMPCSUM4
	CLC
	RTS

.endif

; program 8k block to flash
PROG8K
	JSR FENABLE
	LDX #32
	JSR FWPAGE
	PHP
	JSR FDISABLE
	PLP
	RTS

; program 8k constant value A
PROG8KA
	PHA
	JSR FENABLE
	LDX #32
	PLA
	JSR FWAPAGE
	PHP
	JSR FDISABLE
	PLP
	RTS

; read 8k block from flash
READ8K
	JSR FENABLE
	LDX #32
	JSR FRPAGE
	JSR FDISABLE
	RTS

; verify 8k block with flash
VERIFY8K
	JSR FENABLE
	LDX #32
	JSR FCPAGE
	PHP
	PHA
	JSR FDISABLE
	PLA
	PLP
	RTS

; check if 8k block contains value in A
VERIFY8KA
	PHA
	JSR FENABLE
	LDX #32
	PLA
	JSR FCAPAGE
	PHP
	PHA
	JSR FDISABLE
	PLA
	PLP
	RTS

; erase current 128k block
ERASEBLOCK
	JSR FENABLE
	JSR FPERAS
	PHP
	JSR FDISABLE
	PLP
	RTS

; error loading data
LOADERROR
	JSR PERROR
	SEC
	RTS

; error programming/verifying flash
FLASHERROR
	JSR PERRADR
	JSR PERRTYP
	SEC
	RTS

; load checksum data to RAM
; return C=1 on error
LOADCSUM
	FCOPY2 ICSUMSTART, BLOCKNO
	LDA ICSUMCOUNT
	STA CSCOUNT
	LDA #0
	BIT INCREMENTAL
	BPL ?LOADCS0
; simulate "checksum mismatch" if in initial incremental mode
	LDA #1
?LOADCS0
	STA CSEQUAL
; invalidate checksum cache
	STA CSCACHE_VALID
	JSR SETDATABUF
?LOADCSLP
	LDA #0
	STA BANKNO

	JSR SETUPBLOCK
	JSR PREPAREBLOCK
	BCC ?LOADCSLP1
	RTS
?LOADCSLP1
	JSR SETUPBANK

; check if bank is empty
	BIT BNKSTAT
	BPL ?LOADCSSKIP

; no, we have data
	JSR PFLBNK

	BPUT0 TRDDAT
	JSR LOAD8KSIO_RETRY
	BPL ?LOADCSROK
	JMP RETABORT

?LOADCSSKIP

?LOADCSROK

; checksum equal so far?
	LDA CSEQUAL
	BNE ?LOADCSNOF3	; no, skip further comparisons

	BIT BNKSTAT
	BMI ?LOADCSNOF1
; block is empty
	LDA #$FF
	JSR VERIFY8KA
	JMP ?LOADCSNOF2
?LOADCSNOF1
; compare checksum with flash
	JSR VERIFY8K
?LOADCSNOF2
	BPL ?LOADCSNOF3
	INC CSEQUAL
?LOADCSNOF3

; adjust address
	SUB4 FLASHADR, CSUMADR, FLASHADR

; save to RAM
	JSR MODERAM
	BIT BNKSTAT
	BMI ?LOADCSPROG1
; fill memory with $FF
	LDA #$FF
	JSR PROG8KA
	JMP ?LOADCSPROG2
?LOADCSPROG1
	JSR PROG8K
?LOADCSPROG2
	PHP
	JSR MODEFLASH
	PLP
	BPL ?LOADCSPROG3
	JMP FLASHERROR
?LOADCSPROG3

	BIT BNKSTAT
	BPL ?LOADCSPROG4
	JSR POK
?LOADCSPROG4

	INC BANKNO
	LDA BANKNO
	CMP #BANKSPERBLOCK
	BEQ ?LOADCSLPEB
	JMP ?LOADCSLP1
?LOADCSLPEB
	INC BLOCKNO
	BNE ?LOADCSLPI1
	INC BLOCKNO+1
?LOADCSLPI1
	DEC CSCOUNT
	BEQ ?LOADCSEND
	JMP ?LOADCSLP
?LOADCSEND
	CLC
	RTS

; program checksum data into flash
; return C=1 on error
PROGCSUM
	FCOPY2 ICSUMSTART, BLOCKNO
	LDA ICSUMCOUNT
	STA CSCOUNT
	JSR SETDATABUF
?PROGCSLP
	LDA #0
	STA BANKNO
	JSR SETUPBLOCK
?PROGCSLP1
	JSR SETUPBANK

	BIT BNKSTAT
	BVC ?PROGCSLP1A
; print bank number if bank is to be erased or programmed
	JSR PFLBNK
?PROGCSLP1A

; start of block?
	LDA BANKNO
	BNE ?PROGCSNOERAS

; yes, erase it
	BPUT0 TERAF
	BIT DRYRUN
	BMI ?PROGCSNOERAS
	JSR ERASEBLOCK
	BMI ?PROGCSERR
?PROGCSNOERAS

; block empty?
	BIT BNKSTAT
	BPL ?PROGCSLPOK

?PROGCSLP2
; save flash address
	FCOPY2 FLASHADR+2, CSADRTMP
; adjust address for RAM access
	SUB4 FLASHADR, CSUMADR, FLASHADR
; get checksum from RAM
	JSR MODERAM
	JSR READ8K
	JSR MODEFLASH
; restore flash address
	FCOPY2 CSADRTMP, FLASHADR+2

; program flash bank
	BPUT0 TPROGF
	BIT DRYRUN
	BMI ?PROGCSOK1
	JSR PROG8K
	BPL ?PROGCSOK1
?PROGCSERR
	JMP FLASHERROR
?PROGCSOK1
	BPUT0 TVERIF
	BIT DRYRUN
	BMI ?PROGCSLPOK
	JSR VERIFY8K
	BMI ?PROGCSERR

?PROGCSLPOK
	BIT BNKSTAT
	BVC ?PROGCSLPOK1
	JSR POK
?PROGCSLPOK1

	INC BANKNO
	LDA BANKNO
	CMP #BANKSPERBLOCK
	BEQ ?PROGCSNB
	JMP ?PROGCSLP1
?PROGCSNB
	INC BLOCKNO
	BNE ?PROGCSLPI1
	INC BLOCKNO+1
?PROGCSLPI1
	DEC CSCOUNT
	BEQ ?PROGCSEND
	JMP ?PROGCSLP
?PROGCSEND
	CLC
	RTS

; program flash data
; return C=1 on error
PROGDATA
	LDA #0
	STA BLOCKNO
	STA BLOCKNO+1
?PROGBLKLP
; disable atract mode
	LDA #0
	STA 77
; are we finished?
	LDA BLOCKNO+1
	CMP IBLOCKCOUNT+1
	BCC ?PROGBLKLP2
	BEQ ?PROGBLKLP1
?PROGBLKEND
	CLC
	RTS
?PROGBLKLP1
	LDA BLOCKNO
	CMP IBLOCKCOUNT
	BCS ?PROGBLKEND
?PROGBLKLP2
; are we in incremental mode?
	LDA INCREMENTAL
	BEQ ?PROGBLKLPNOI

; yes: check if we reached the checksum area
	LDA BLOCKNO
	CMP ICSUMSTART
	BNE ?PROGBLKLPNOI
	LDA BLOCKNO+1
	CMP ICSUMSTART+1
	BNE ?PROGBLKLPNOI
; skip over checksum area
	CLC
	LDA BLOCKNO
	ADC ICSUMCOUNT
	STA BLOCKNO
	BCC ?PROGBLKLP
	INC BLOCKNO+1
	JMP ?PROGBLKLP

?PROGBLKLPNOI
	JSR SETUPBLOCK
; compare checksum (incremental mode handled there, too)
	JSR CMPCSUM
	BCS ?PROGBLK1
	JMP ?PROGBLKNEXT

?PROGBLK1
	LDA BLOCKMAP
	ORA BLOCKMAP+1
	BEQ ?PROGBLK2		; skip disk setup if bank is empty
	JSR PREPAREBLOCK
	BCC ?PROGBLK2
	RTS
?PROGBLK2
	LDA #0
	STA BANKNO

	JSR SETDATABUF
; bank loop
?PROGBNKLP
	JSR SETUPBANK

	BIT BNKSTAT
	BVC ?PROGBNKLP1
	JSR PFLBNK
?PROGBNKLP1

	LDA BANKNO
	BNE ?PROGBNKNOERAS

; erase block
	BPUT0 TERAF
	BIT DRYRUN
	BMI ?PROGBNKNOERAS
	JSR ERASEBLOCK
	BPL ?PROGBNKNOERAS
	JMP FLASHERROR

?PROGBNKNOERAS
	BIT BNKSTAT
	BPL ?PROGBNKNEXT

?PROGBNKNOEMPTY
	BPUT0 TRDDAT
	JSR LOAD8KSIO_RETRY
	BPL ?PROGBNKLOADOK
	JMP RETABORT
?PROGBNKLOADOK
	BPUT0 TPROGF
	BIT DRYRUN
	BMI ?PROGBNKPROGOK
	JSR PROG8K
	BPL ?PROGBNKPROGOK
?PROGBNKPROGERR
	JMP FLASHERROR
?PROGBNKPROGOK
	BPUT0 TVERIF
	BIT DRYRUN
	BMI ?PROGBNKNEXT
	JSR VERIFY8K
	BMI ?PROGBNKPROGERR

?PROGBNKNEXT
	BIT BNKSTAT
	BVC ?PROGBNKNEXT1
	JSR POK
?PROGBNKNEXT1

	INC BANKNO
	LDA BANKNO
	CMP #BANKSPERBLOCK
	BNE ?PROGBNKLP

?PROGBLKNEXT
	INC BLOCKNO
	BNE ?PROGBLKNEXT1
	INC BLOCKNO+1
?PROGBLKNEXT1
	JMP ?PROGBLKLP

; program studio data
; return C=1 on error
PROGALL
	LDA INCREMENTAL
	BEQ ?PROGACSNE

	BPUT0 TLOADCS
	JSR LOADCSUM

	BCC ?PROGALCSOK
	RTS
?PROGALCSOK
; check if checksum data is equal
	LDA CSEQUAL
	BNE ?PROGACSNE
	BPUT0 TCSEQU
	CLC
	RTS

?PROGACSNE
	BPUT0 TPROGD
	JSR PROGDATA
	BCC ?PROGDATAOK
	RTS
?PROGDATAOK
	LDA INCREMENTAL
	BNE ?PROGACS
	CLC
	RTS
?PROGACS
	BPUT0 TPROGCS
	JSR PROGCSUM
	RTS


; program (incremental) data
PROGINCR
; input drive number
	JSR INPUTDRV
	BCC ?PROGINCR1
	JMP RETABORT

?PROGINCR1
; check drive and density
	LDA CURDRIVENO
	JSR CHKDENS
	BCC ?PROGINCR2
	JSR PNODISK
	RTS

?PROGINCR2
; check for valid density
	STA DRIVEDNS
	CMP #DRIVEDNS_8K
	BEQ ?PROGINCR3
	CMP #DRIVEDNS_DD
	BEQ ?PROGINCR3
	PRINT0 TUNSUPDNS
	RTS

?PROGINCR3
; load header
	BPUT0 TLOADHDR
	JSR LOADHEADER
	BPL ?PROGINCR4
	JMP LOADERROR

?PROGINCR4
; verify and parse header
	JSR PARSEHEADER
	BCC ?PROGINCR5
	PRINT0 TILLPSIG
	RTS

?PROGINCR5
; print info from header
	LDA #155
	JSR PUTCHAR

; copy name to FNBUF, add EOL at end
	LDA #155
	STA FNBUF+PHNAMELEN
; copy name to FNBUF
	LDX #PHNAMELEN-1
?PROGINCR5L
	LDA DATABUF+PHNAME,X
	STA FNBUF,X
	DEX
	BPL ?PROGINCR5L
	PRINT0 FNBUF

	PRINT0 DATABUF+PHTIMESTAMP
	LDA #155
	JSR PUTCHAR

; print number of banks (blocks * 16)
	LDA IBLOCKCOUNT
	STA BLOCKNO
	STA BLOCKBANK
	LDA IBLOCKCOUNT+1
	STA BLOCKNO+1
	STA BLOCKBANK+1

	JSR MULTBLOCKBANK

	LDX BLOCKBANK
	LDY BLOCKBANK+1
	JSR PRDEC
	BPUT0 TUBANK

; check if programming image fits into cart
	JSR SETUPBLOCKFADR
	LDX #3
?CHKSIZLP
	LDA BLOCKFADR,X
	CMP FSIZE,X
	BCC ?CHKSIZOK
	BNE ?CHKSIZERR
	DEX
	BPL ?CHKSIZLP
?CHKSIZOK
	JMP ?CHKSIZEND
?CHKSIZERR
	BPUT0 TTOOBIG
	SEC
	RTS
?CHKSIZEND

	LDA #0
	STA SUBSEQUENT

	LDA DRIVEDNS
	CMP #DRIVEDNS_8K
	BEQ ?PROGINCR7

; print number of parts
	LDX DATABUF+PHPARTS
	LDY #0
	JSR PRDEC
	PRINT0 TTOTPART

	LDA DATABUF+PHPARTS
	CMP #1
	BEQ ?PROGINCR7
	BPUT0 TSUBSEQ
	JSR YESNO
	BPL ?PROGINCR6
	JMP RETABORT
?PROGINCR6
	BNE ?PROGINCR7
	INC SUBSEQUENT
	JMP ?PROGINCR7

?PROGINCR7
	LDA #155
	JSR PUTCHAR

	LDA #0
	STA INCREMENTAL
; check if programming header signature matches flash signature
	JSR CHKFLASHSIG_HDR
	BMI ?PROGINCR8		; no checksums in programming file
	LDX #$81
	BCS ?PROGINCR7A		; checksums only in programming file
	LDX #1			; standard incremental mode
?PROGINCR7A
	STX INCREMENTAL

?PROGINCR8
	LDA INCREMENTAL
	BEQ ?PROGINCR10
	BMI ?PROGINCR10

; ask if we should perform an incremental update
	BPUT0 TDOINCR
	JSR YESNO
	BPL ?PROGINCR9
	JMP RETABORT
?PROGINCR9
	PHP
	LDA #155
	JSR PUTCHAR
	PLP
	BEQ ?PROGINCR10

	LDA #$81		; perform initial incremental update
	STA INCREMENTAL
	
?PROGINCR10
	BPUT0 TDOPROG
	JSR YESNO
	PHP
	LDA #155
	JSR PUTCHAR
	PLP
	BEQ ?PROGINCR11
	JMP RETABORT
?PROGINCR11
	JSR PROGALL
	BCS ?PROGINCEND
	BPUT0 TFINI
?PROGINCEND
	RTS

; load 8k into databuf, ask to retry in case of error
; return: N=1 on error
LOAD8KSIO_RETRY
	LDA DAUX1
	STA DAUX_SAVE
	LDA DAUX2
	STA DAUX_SAVE+1
?LOAD8KSIO_RETRYLP
	LDA DAUX_SAVE
	STA DAUX1
	LDA DAUX_SAVE+1
	STA DAUX2
	JSR LOAD8KSIO
	BMI ?LOAD8KSIO_RETRY1
	RTS

?LOAD8KSIO_RETRY1
	LDA #155
	JSR PUTCHAR
	JSR PREADERR
	BPUT0 TRETRY
	JSR YESNO
	PHP
	LDA #155
	JSR PUTCHAR
	PLP
	BEQ ?LOAD8KSIO_RETRYLP
	LDY DSTATS
	RTS

