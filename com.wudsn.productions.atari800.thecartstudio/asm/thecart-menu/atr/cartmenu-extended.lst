mads 2.0.6 build 58 (28 Jan 17)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Extended.asm
     1
     2 				;	>>> The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.outputfile=cartmenu-extended.rom
     5 				;
     6
     7 = FFFF0001			.def alignment_mode	;Enforce alignment
     8
     9 = 0080			p1		= $80		;General purpose ZP pointer (not in interrupts)
    10 = 0082			p2		= $82		;General purpose ZP pointer (not in interrupts)
    11 = 0084			p3		= $84		;General purpose ZP pointer (not in interrupts)
    12 = 0086			x1		= $86		;General purpose ZP variable (not in interrupts)
    13 = 0087			x2		= $87		;General purpose ZP variable (not in interrupts)
    14
    15 = 00A0			menu_mcb_zp	= $a0		;The menu control block in zero page ($a0-$df)
    16 = 00E0			carmenu_zp	= $e0		;Cartmenu zero page ($e0-$e1)
    17 = 00E2			vbi_zp		= $e2		;Extended menu zero page ($e2-$ff)
    18
    19 = 2400			data_start	= $2400		;Code must end before this address
    20 = 2400			chr		= data_start	;Charset in RAM below module (1K)
    21 = 2800			pm		= chr+$400 	;Player Missle graphics in RAM below module (2K)
    22 = 3000			sm		= pm+$800	;Screen in RAM below module (1K)
    23 = 3400			menu_data_start = $3400		;The menu uses this are as buffer
    24 = 9FFF			menu_data_end	= $9fff		;until the end of the RAM
    25
    26 = A000			module_a000	= $a000		;Standard ROM base address
    27 = 2000			bank_size	= $2000		;In native mode, all banks are always 8k
    28
    29
    30 = 0700			menu_start_ram	= $0700		;Start of the menu ROM copy and start routine in RAM 
    31 = 0800			menu_main_ram	= $0800		;Start of the menu main souring in RAM 
    32 = B800			menu_atr_rom 	= $b800		;Start of the menu SIO ROM routine used by the ATR starter
    33 = BE00			menu_start_rom  = $be00		;Start of the menu ROM copy and start routine in ROM 
    34 = BF00			menu_mcb_rom	= $bf00		;The menu control block in ROM 
    35 = 0034			menu_mcb_size	= $0c+$28	;Size of the menu control block, $0c bytes header plus $28 bytes title
    36 = BFE0			menu_signature	= $bfe0		;16 bytes like "The!Cart99991231"
    37
    38 = 00A0			menu_mcb.cartridge_type			= menu_mcb_zp + $00; ZP address of the cartridge type (byte)
    39 = 00A2			menu_mcb.bank_count			= menu_mcb_zp + $02; ZP address of the bank count (word)
    40 = 00A4			menu_mcb.menu_genres_count		= menu_mcb_zp + $04; ZP address of the genres count (word)
    41 = 00A6			menu_mcb.menu_genres_start_bank_number	= menu_mcb_zp + $06; ZP address of the start bank (word)
    42 = 00A8			menu_mcb.menu_entries_count		= menu_mcb_zp + $08; ZP address of the entries count (word)
    43 = 00AA			menu_mcb.menu_entries_start_bank_number	= menu_mcb_zp + $0a; ZP address of the start bank (word)
    44 = 00AC			menu_mcb.menu_title			= menu_mcb_zp + $0c; ZP address of the title ($28 bytes)
    45
    46 = 0008			menu_start_bank	= 8
    47 = 0040			menu_entry_size	= 64
    48
    49 				;===============================================================
    50
    51 					.enum menu_entry
    52 = 0000				number			= 0	; Word
    53 = 0002				the_cart_mode 		= 2	; Byte
    54 = 0004				start_bank_number	= 4	; Word
    55 = 0006				initial_bank_number	= 6	; Word
    56 = 0008				loader_base_address	= 8	; Word
    57 = 000A				source_type		= 10	; Byte
    58 = 000B				item_menu_version	= 11	; Byte
    59 = 000C				item_number		= 12	; Byte
    60 = 000D				title_length		= 13	; Byte
    61 = 000E				title			= 14	; 40 Bytes
    62 = 0036				genre_number		= 54	; Byte, 0 means no genre assigned
    63 = 0037				favorite_indicate	= 55	; Byte
    64 					.ende
    65 					
    66 					.enum menu_entry_source_type
    67 = 0000				menu_entry 		= 0	; Constant
    68 = 0001				menu_entry_item		= 1	; Constant
    69 					.ende
    70
    71 				;===============================================================
    72
    73 				;+---------------------------------------------------------------------------+
    74 				;| Type 41: Atarimax 128 KB Flash cartridge                                  |
    75 				;+---------------------------------------------------------------------------+
    76 				;
    77 				; This bank-switched cartridge occupies 8 KB of address space between $A000
    78 				; and $BFFF. The cartridge memory is divided into 16 banks, 8 KB each.
    79 				; The 4 lowest bits of the address written to $D500-$D50F select the bank
    80 				; mapped to $A000-$BFFF. Writing to $D510-$D51F disables the cartridge
    81 				; and any write to $D520-$D5FF is ignored.
    82 				;
    83 				;+---------------------------------------------------------------------------+
    84 				;| Type 42: Atarimax 1 MB Flash cartridge                                    |
    85 				;+---------------------------------------------------------------------------+
    86 				;
    87 				; This bank-switched cartridge occupies 8 KB of address space between $A000
    88 				; and $BFFF. The cartridge memory is divided into 128 banks, 8 KB each.
    89 				; The seven lowest bits of the address written to $D500-$D57F select the bank
    90 				; mapped to $A000-$BFFF, bit 7 disables the cartridge.
    91
    92 					.enum cartridge_type
    93 = 002A				CARTRIDGE_ATMAX_1024	= 42
    94 = 0041				CARTRIDGE_THECART_32M	= 65
    95 = 0042				CARTRIDGE_THECART_64M	= 66
    96 = 003E				CARTRIDGE_THECART_128M	= 62
    97 					.ende
    98
    99 					icl "CartMenu-Kernel-Equates.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5 				;
     6 				;	.def alignment_mode should be used by default in parent program 
     7
     8 					.enum opcode
     9 = 000A			asl	= $0a
    10 = 0069			adc_imm	= $69
    11 = 002C			bit_abs	= $2c
    12 = 00D0			bne	= $d0
    13 = 00C6			dec_zp	= $c6
    14 = 0045			eor_zp	= $45
    15 = 00E6			inc_zp	= $e6
    16 = 00B3			lax_izy	= $b3	;LAX (zp),y
    17 = 00A7			lax_zp	= $a7	;LAX zp
    18 = 00AD			lda_abs	= $ad
    19 = 00A9			lda_imm = $a9
    20 = 00A5			lda_zp	= $a5
    21 = 00B1			lda_zpy	= $b1
    22 = 0060			rts     = $60
    23 = 008D			sta_abs	= $8d
    24 = 0091			sta_zpy	= $91
    25 					.ende
    26 					
    27 					.enum cio_command
    28 = 0003				open = 3
    29 = 0007				get_character = 7
    30 = 000C				close = 12
    31 = 0028				run_executable = 40
    32 = 0029				change_directory = 41	
    33 					.ende
    34
    35 				; Zero page
    36 = 0008			warmst = $08
    37 = 0009			boot?  = $09
    38 = 000A			dosvec = $0a
    39 = 000C			dosini = $0c
    40 = 0010			pokmsk = $10
    41 = 0011			brkkey = $11
    42 = 0052			lmargn = $52
    43 = 0054			rowcrs = $54
    44 = 0058			savmsc = $58
    45 = 006A			ramtop = $6a
    46 = 0079			keydef = $79
    47
    48 				; Page 2
    49 = 0200			vdslst	= $200
    50 = 0206			vbreak	= $206
    51 = 0222			vvblki	= $222
    52 = 0224			vvblkd	= $224
    53
    54 = 022F			sdmctl	= $22f
    55 = 0230			sdlstl	= $230
    56 = 0231			sdlsth	= $231
    57 = 0244			coldst	= $244
    58 = 026F			gprior	= $26f
    59 = 0278			stick0	= $278
    60 = 0284			strig0	= $284
    61
    62 = 02D9			krpdel	= $2d9
    63 = 02DA			keyrep	= $2da
    64
    65 = 02EA			dvstat	= $2ea				;Bit 7=1 means disk is ED, bit 5=1 means disk is DD
    66
    67 = 02C0			pcolor0	= $2c0
    68 = 02C1			pcolor1	= $2c1
    69 = 02C2			pcolor2	= $2c2
    70 = 02C3			pcolor3	= $2c3
    71 = 02C4			color0	= $2c4
    72 = 02C5			color1	= $2c5
    73 = 02C6			color2	= $2c6
    74 = 02C7			color3	= $2c7
    75 = 02C8			color4	= $2c8
    76 = 02DC			helpfg	= $02dc	;XL help key flag
    77 = 02E4			ramsiz	= $2e4
    78 = 02E5			memtop	= $2e5	;End of physical RAM (word)
    79 = 02F0			crsinh	= $2f0
    80 = 02F3			chact	= $2f3	;Shadow of chactl ($d401)
    81 = 02F4			chbas	= $2f4
    82 = 02FC			ch	= $2fc
    83
    84 = 0241			dbsect  = $241 ;Disk boot sector count ($00 = $100)
    85 = 0242			bootad  = $242 ;Disk boot sector load address
    86 = 0300			ddevic	= $300	;Device id
    87 = 0301			dunit	= $301	;Device number
    88 = 0302			dcomnd	= $302	;Command byte
    89 = 0303			dstats	= $303	;Status byte
    90 = 0304			dbuflo	= $304	;Data buffer pointer, lo
    91 = 0305			dbufhi	= $305	;Data buffer pointer, hi
    92 = 0306			dtimlo	= $306	;Timout value
    93 = 0308			dbytlo	= $308	;Number of bytes to transfer, lo
    94 = 0309			dbythi	= $309	;Number of bytes to transfer, hi
    95 = 030A			daux1	= $30a	;Sent to device (sector number lo)
    96 = 030B			daux2	= $30b	;Sent to device (sector number high)
    97
    98 = 0340			iocb   = $340	;832
    99 = 0340			ichid  = $340	;832
   100 = 0341			icdno  = $341	;833
   101 = 0342			iccom  = $342	;834
   102 = 0343			icsta  = $343	;835
   103 = 0344			icbal  = $344	;836
   104 = 0345			icbah  = $345	;837
   105 = 0346			icptl  = $346	;838
   106 = 0347			icpth  = $347	;839
   107 = 0348			icbll  = $348	;840
   108 = 0349			icblh  = $349	;841
   109 = 034A			icax1  = $34a	;842
   110 = 034B			icax2  = $34b	;843
   111 = 034C			icax3  = $34c	;844
   112 = 034D			icax4  = $34d	;845
   113 = 034E			icax5  = $34e	;846
   114 = 034F			icax6  = $34f	;847
   115 = 03F8			basicf = $3f8
   116 = 03FA			gintlk = $3fa
   117
   118 				; GTIA
   119 = D000			gtia	= $d000
   120 = D000			hposp0	= $d000
   121 = D001			hposp1	= $d001
   122 = D002			hposp2	= $d002
   123 = D003			hposp3	= $d003
   124 = D004			hposm0	= $d004
   125 = D005			hposm1	= $d005
   126 = D006			hposm2	= $d006
   127 = D007			hposm3	= $d007
   128 = D008			sizep0	= $d008
   129 = D009			sizep1	= $d009
   130 = D00A			sizep2	= $d00a
   131 = D00B			sizep3	= $d00b
   132 = D00C			sizem	= $d00c
   133 = D00D			grafp0	= $d00d
   134 = D00E			grafp1	= $d00e
   135 = D00F			grafp2	= $d00f
   136 = D010			grafp3	= $d010
   137 = D010			trig0	= $d010
   138 = D013			trig3	= $d013
   139 = D011			grafm	= $d011
   140 = D012			colpm0	= $d012
   141 = D013			colpm1	= $d013
   142 = D014			colpm2	= $d014
   143 = D015			colpm3	= $d015
   144 = D016			colpf0	= $d016
   145 = D017			colpf1	= $d017
   146 = D018			colpf2	= $d018
   147 = D019			colpf3	= $d019
   148 = D01A			colbk	= $d01a
   149 = D01B			prior	= $d01b
   150 = D01D			gractl	= $d01d
   151 = D01E			hitclr	= $d01e
   152 = D01F			consol	= $d01f
   153
   154 				; POKEY
   155 = D200			pokey	= $d200
   156 = D200			audf1	= $d200
   157 = D201			audc1	= $d201
   158 = D209			kbcode	= $d209
   159 = D20A			random	= $d20a
   160 = D20E			irqen	= $d20e
   161 = D20F			skctl	= $d20f
   162 = D20F			skstat	= $d20f
   163
   164 				;PIA
   165 = D300			porta	= $d300
   166 = D301			portb	= $d301
   167
   168
   169 				; ANTIC
   170 = D400			antic	= $d400
   171 = D400			dmactl	= $d400
   172 = D401			chactl	= $d401
   173 = D402			dlptr 	= $d402
   174 = D404			hscrol	= $d404
   175 = D405			vscrol	= $d405
   176 = D407			pmbase	= $d407
   177 = D409			chbase	= $d409
   178 = D40A			wsync 	= $d40a
   179 = D40B			vcount	= $d40b
   180 = D40E			nmien	= $d40e
   181 = D40F			nmist	= $d40f
   182 = D40F			nmires	= $d40f
   183
   184 				; ROM
   185 = E456			ciov	= $e456	;Central I/O handler vector
   186 = E459			siov	= $e459	;Serial I/O handler vector
   187 = E45C			setvbv	= $e45c	;<A>=6 (immediate) ot 7 (deferred), <X>=high, <Y>=low
   188 = 0006			setvbv.immediate = 6
   189 = 0007			setvbv.deferred = 7
   190 = E45F			sysvbv	= $e45f	;End of immediate VBI
   191 = E462			xitvbv	= $e462	;End of deferred VBI
   192 = E474			warmsv	= $e474	;Warmstart vector
   193 = E477			coldsv	= $e477	;Coldstart vector
   194
   195 				;===============================================================
   196 				;	Stop emulation and open monitor
   197 					.macro jam
   198 					.byte $02
   199 					.endm
   200
   201 					
   202 				;===============================================================
   203 				;	Indicate end of program
   204 					.macro xx
   205 				loop	lda vcount
   206 					sta colbk
   207 					jmp loop
   208 					.endm
   209
   210 				;===============================================================
   211 					.macro m_info	;Works with ranges like ".PROC", ".LOCAL"
   212 					.print ":1: " , :1, " - ", :1 + .len :1 -1, " (", .len :1,")"
   213 					.endm
   214
   215 					.macro m_align_page	;Fills with 0 and prints how much space is "lost"
   216 					here = *
   217 					size = [[[here+255]/256]*256]-*
   218 					.print "Alignment added at ",here,": ", size, " bytes."
   219 					.rept size
   220 					.byte 0
   221 					.endr
   222 					.endm
   223
   224 					.macro m_assert_same_page ;For timing critical loop or ranges enclosed by ".PROC" or ".LOCAL"
   225 					.if :1 / $100 <> (:1 + .len :1 - 1) / $100
   226 						.if .def alignment_mode
   227 							.error ":1 crosses page boundary between ", :1, " - ", :1 + .len :1 - 1
   228 						.else
   229 							.print ":1 crosses page boundary between ", :1, " - ", :1 + .len :1 - 1
   230 						.endif
   231 					.else
   232 						.print ":1 within page boundary between ", :1, " - ", :1 + .len :1 - 1
   233 					.endif
   234 					.endm
   235
   236 					.macro m_assert_same_1k	;For Display Lists
   237 					.if :1 / $400 <> (:1 + .len :1 - 1) / $400
   238 						.if .def alignment_mode
   239 							.error ":1 crosses 1k boundary between ", :1, " - ", :1 + .len :1 - 1
   240 						.else
   241 							.print ":1 crosses 1k boundary between ", :1, " - ", :1 + .len :1 - 1
   242 						.endif
   243 					.else
   244 						.print ":1 within 1k boundary between ", :1 , " - ", :1 + [.len :1 ] - 1
   245 					.endif
   246 					.endm
   247
   248 					.macro m_assert_align	; Uses .def alignment_mode to control if misaligment is error or warning
   249 					.if :1 / :2 <> (:1 + .len :1 - 1) / :2
   250 						.if .def alignment_mode
   251 							.error ":1 crosses ",:2," boundary between ", :1 , " - ", :1 + :2 - 1
   252 						.else
   253 							.print ":1 crosses ",:2," boundary between ", :1 , " - ", :1 + :2 - 1
   254 						.endif
   255 					.else
   256 						.print ":1 within ",:2," boundary between ", :1, " - ", :1 + .len :1 - 1
   257 					.endif
   258 					.endm
   259
   260 					.macro m_assert_end_of_code ;For assuring the code does not overlap some data	
   261 				end_of_code
   262 					.if end_of_code > :1
   263 					.error "END_OF_CODE (",end_of_code,") > :1 (",:1,"), ", end_of_code-:1, " bytes too far" 
   264 					.else
   265 					.print "END_OF_CODE (",end_of_code,") <= :1 (",:1,"), ", :1-end_of_code, " bytes free" 
   266 					.endif
   267 					.endm
   268
   269 				;;
   270 				;; ATARI 800 SYSTEM EQUATE LISTING
   271 				;;
   272 				;; Tranferred to ATASM format by JAC! on 2010-11-11 based on
   273 				;; http://evilbill.org/old/orig/Atari/8-Bit/Refman/appendixB.html.
   274 				;; Formatted using tabs for a tab width of 8 characters.
   275 				;; Last update on 2010-11-11.
   276 				;;
   277 				;; This listing is based on the original release of Operating System,
   278 				;; version A. The vectors shown here were not changed in version B.
   279 				;; New equates for XL and XE models are included and noted. 
   280 				;; Changes from version B to XL/XE are also noted.
   281 				;;
   282 				;; Most of the equate names given below are the official Atari names.
   283 				;; They are in common use but are not mandatory.
   284 				;
   285 				;;
   286 				;;
   287 				;;	DEVICE NAMES
   288 				;;
   289 				;;
   290 				;;SCREDT = "E"	;SCREEN EDITOR
   291 				;;KBD    = "K"	;KEYBOARD
   292 				;;DISPLY = "S"	;DISPLAY
   293 				;;PRINTR = "P"	;PRINTER
   294 				;;CASSET = "C"	;CASSETTE
   295 				;;DISK   = "D"	;DISK DRIVE
   296 				;
   297 				;;
   298 				;;
   299 				;;	STATUS CODES
   300 				;;
   301 				;;
   302 				;SUCCES = $01	;  1
   303 				;BRKABT = $80	;128 BREAK KEY ABORT
   304 				;PRVOPN = $82	;130 IOCB ALREADY OPEN
   305 				;NONDEV = $82	;130 NONEXISTANT DEVICE
   306 				;WRONLY = $83	;131 OPENED FOR WRITE ONLY
   307 				;NVALID = $84	;132 INVALID COMMAND
   308 				;NOTOPN = $85	;133 DEVICE OR FILE NOT OPEN
   309 				;BADIOC = $86	;134 INVALID IOCB NUMBER
   310 				;RDONLY = $87	;135 OPENED FOR READ ONLY
   311 				;EOFERR = $88	;136 END OF FILE
   312 				;TRNRCD = $89	;137 TRUNCATED RECORD
   313 				;TIMOUT = $8A	;138 PERIPHERAL TIME OUT
   314 				;DNACK  = $8B	;139 DEVICE DOES NOT ACKNOWLEDGE
   315 				;FRMERR = $8C	;140 SERIAL BUS FRAMING ERROR
   316 				;CRSROR = $8D	;141 CURSOR OUT OF RANGE
   317 				;OVRRUN = $8E	;142 SERIAL BUS DATA OVERRUN
   318 				;CHKERR = $8F	;143 SERIAL BUS CHECKSUM ERROR
   319 				;DERROR = $90	;144 PERIPHERAL DEVICE ERROR
   320 				;BADMOD = $91	;145 NON EXISTANT SCREEN MODE
   321 				;FNCNOT = $92	;146 FUNCTION NOT IMPLEMENTED
   322 				;SCRMEM = $93	;147 NOT ENOUGH MEMORY FOR SCREEN MODE
   323 				;
   324 				;;
   325 				;;
   326 				;;
   327 				;;	COMMAND CODES FOR CIO
   328 				;;
   329 				;;
   330 				;OPEN   = $03	;  3
   331 				;OPREAD = $04	;  4 OPEN FOR INPUT
   332 				;GETREC = $05	;  5 GET RECORD
   333 				;OPDIR  = $06	;  6 OPEN TO DISK DIRECTORY
   334 				;GETCHR = $07	;  7 GET BYTE
   335 				;OWRITE = $08	;  8 OPEN FOR OUTPUT
   336 				;PUTREC = $09	;  9 WRITE RECORD
   337 				;APPEND = $09	;  9 OPEN TO APPEND TO END OF DISK FILE
   338 				;MXDMOD = $10	; 16 OPEN TO SPLIT SCREEN (MIXED MODE)
   339 				;PUTCHR = $0B	; 11 PUT-BYTE
   340 				;CLOSE  = $0C	; 12
   341 				;OUPDAT = $0C	; 12 OPEN FOR INPUT AND OUTPUT AT THE SAME TIME
   342 				;STATUS = $0D	; 13
   343 				;SPECIL = $0E	; 14 BEGINNING OF SPECIAL COMMANDS
   344 				;DRAWLN = $11	; 17 SCREEN DRAW
   345 				;FILLIN = $12	; 18 SCREEN FILL
   346 				;RENAME = $20	; 32
   347 				;INSCLR = $20	; 32 OPEN TO SCREEN BUT DON'T ERASE
   348 				;DELETE = $21	; 33
   349 				;DFRMAT = $21	; 33 FORMAT DISK (RESIDENT DISK HANDLER (RDH))
   350 				;LOCK   = $23	; 35
   351 				;UNLOCK = $24	; 36
   352 				;POINT  = $25	; 37
   353 				;NOTE   = $26	; 38
   354 				;PTSECT = $50	; 80 RDH PUT SECTOR
   355 				;GTSECT = $52	; 82 RDH GET SECTOR
   356 				;DSTAT  = $53	; 83 RDH GET STATUS
   357 				;PSECTV = $57	; 87 RDH PUT SECTOR AND VERIFY
   358 				;NOIRG  = $80	;128 NO GAP CASSETTE MODE
   359 				;CR     = $9B	;155 CARRIAGE RETURN (EOL)
   360 				;;
   361 				;IOCBSZ = $10	; 16 IOCB SIZE
   362 				;MAXIOC = $80	;128 MAX IOCB BLOCK SIZE
   363 				;IOCBF  = $FF	;255 IOCB FREE
   364 				;;
   365 				;LEDGE  = $02	;  2 DEFAULT LEFT MARGIN
   366 				;REDGE  = $27	; 39 DEFAULT RIGHT MARGIN
   367 				;;
   368 				;;	OS VARIABLES
   369 				;;
   370 				;;	PAGE 0
   371 				;;
   372 				;LINZBS = $00	;  0 (800) FOR ORIGINAL DEBUGGER
   373 				;;	 $00	;  0 (XL) RESERVED
   374 				;NGFLAG = $01	;  1 (XL) FOR POWER-UP SELF TEST
   375 				;CASINI = $02	;  2
   376 				;RAMLO  = $04	;  4 POINTER FOR SELF TEST
   377 				;TRAMSZ = $06	;  6 TEMPORARY RAM SIZE
   378 				;TSTDAT = $07	;  7 TEST DATA
   379 				;WARMST = $08	;  8
   380 				;BOOT?  = $09	;  9 SUCCESSFUL BOOT FLAG
   381 				;DOSVEC = $0A	; 10 PROGRAM RUN VECTOR
   382 				;DOSINI = $0C	; 12 PROGRAM INITIALIZATION
   383 				;APPMHI = $0E	; 14 DISPLAY LOW LIMIT
   384 				;POKMSK = $10	; 16 IRQ ENABLE FLAGS
   385 				;BRKKEY = $11	; 17 FLAG
   386 				;RTCLOK = $12	; 18 3 BYTES, MSB FIRST
   387 				;BUFADR = $15	; 21 INDIRECT BUFFER ADDRESS
   388 				;ICCOMT = $17	; 23 COMMAND FOR VECTOR
   389 				;DSKFMS = $18	; 24 DISK FILE MANAGER POINTER
   390 				;DSKUTL = $1A	; 26 DISK UTILITY POINTER (DUP.SYS)
   391 				;PTIMOT = $1C	; 28 (800) PRINTER TIME OUT REGISTER
   392 				;ABUFPT = $1C	; 28 (XL) RESERVED
   393 				;PBPNT  = $1D	; 29 (800) PRINTER BUFFER POINTER
   394 				;;	 $1D	; 29 (XL) RESERVED
   395 				;PBUFSZ = $1E	; 30 (800) PRINTER BUFFER SIZE
   396 				;;	 $1E	; 30 (XL) RESERVED
   397 				;PTEMP  = $1F	; 31 (800) TEMPORARY REGISTER
   398 				;;	 $1F	; 31 (XL) RESERVED
   399 				;ZIOCB  = $20	; 32 ZERO PAGE IOCB
   400 				;ICHIDZ = $20	; 32 HANDLER INDEX NUMBER (ID)
   401 				;ICDNOZ = $21	; 33 DEVICE NUMBER
   402 				;ICCOMZ = $22	; 34 COMMAND
   403 				;ICSTAZ = $23	; 35 STATUS
   404 				;ICBALZ = $24	; 36 BUFFER POINTER LOW BYTE
   405 				;ICBAHZ = $25	; 37 BUFFER POINTER HIGH BYTE
   406 				;ICPTLZ = $26	; 38 PUT ROUTINE POINTER LOW
   407 				;ICPTHZ = $27	; 39 PUT ROUTINE POINTER HIGH
   408 				;ICBLLZ = $28	; 40 BUFFER LENGTH LOW
   409 				;ICBLHZ = $29	; 41
   410 				;ICAX1Z = $2A	; 42 AUXILIARY INFORMATION BYTE 1
   411 				;ICAX2Z = $2B	; 43
   412 				;ICSPRZ = $2C	; 44 TWO SPARE BYTES (CIO USE)
   413 				;ICIDNO = $2E	; 46 IOCB NUMBER X 16
   414 				;CIOCHR = $2F	; 47 CHARACTER BYTE FOR CURRENT OPERATION
   415 				;;
   416 				;STATUS = $30	; 48 STATUS STORAGE
   417 				;CHKSUM = $31	; 49 SUM WITH CARRY ADDED BACK
   418 				;BUFRLO = $32	; 50 DATA BUFFER LOW BYTE
   419 				;BUFRHI = $33	; 51
   420 				;BFENLO = $34	; 52 ADDRESS OF LAST BUFFER BYTE +1 (LOW)
   421 				;BFENHI = $35	; 53
   422 				;CRETRY = $36	; 54 (800) NUMBER OF COMMAND FRAME RETRIES
   423 				;LTEMP  = $36	; 54 (XL) LOADER TEMPORARY STORAGE, 2 BYTES
   424 				;DRETRY = $37	; 55 (800) DEVICE RETRIES
   425 				;BUFRFL = $38	; 56 BUFFER FULL FLAG
   426 				;RECVDN = $39	; 57 RECEIVE DONE FLAG
   427 				;XMTDON = $3A	; 58 TRANSMISSION DONE FLAG
   428 				;CHKSNT = $3B	; 59 CHECKSUM-SENT FLAG
   429 				;NOCKSM = $3C	; 60 CHECKSUM-DOES-NOT-FOLLOW-DATA FLAG
   430 				;BPTR   = $3D	; 61
   431 				;FTYPE  = $3E	; 62
   432 				;FEOF   = $3F	; 63
   433 				;FREQ   = $40	; 64
   434 				;;
   435 				;SOUNDR = $41	; 65 0=QUIET I/O
   436 				;CRITIC = $42	; 66 CRITICAL FUNCTION FLAG, NO DEFFERED VBI
   437 				;FMSZPG = $43	; 67 DOS ZERO PAGE, 7 BYTES
   438 				;CKEY   = $4A	; 74 (800) START KEY FLAG
   439 				;ZCHAIN = $4A	; 74 (XL) HANDLER LOADER TEMP, 2 BYTES
   440 				;CASSBT = $4B	; 75 (800) CASSETTE BOOT FLAG
   441 				;DSTAT  = $4C	; 76 DISPLAY STATUS
   442 				;;
   443 				;ATRACT = $4D	; 77
   444 				;DRKMSK = $4E	; 78 ATTRACT MASK
   445 				;COLRSH = $4F	; 79 ATTRACT COLOR SHIFTER (EORed WITH GRAPHICS)
   446 				;;
   447 				;TMPCHR = $50	; 80
   448 				;HOLD1  = $51	; 81
   449 				;LMARGN = $52	; 82 SCREEN LEFT MARGIN REGISTER
   450 				;RMARGN = $53	; 83 SCREEN RIGHT MARGIN
   451 				;ROWCRS = $54	; 84 CURSOR ROW
   452 				;COLCRS = $55	; 85 CURSOR COLUMN, 2 BYTES
   453 				;DINDEX = $57	; 87 DISPLAY MODE
   454 				;SAVMSC = $58	; 88 SCREEN ADDRESS
   455 				;OLDROW = $5A	; 90 CURSOR BEFORE DRAW OR FILL
   456 				;OLDCOL = $5B	; 91
   457 				;OLDCHR = $5D	; 93 DATA UNDER CURSOR
   458 				;OLDADR = $5E	; 94 CURSOR ADDRESS
   459 				;NEWROW = $60	; 96 (800) DRAWTO DESTINATION
   460 				;FKDEF  = $60	; 96 (XL) FUNCTION KEY DEFINATION POINTER
   461 				;NEWCOL = $61	; 97 (800) DRAWTO DESTINATION, 2 BYTES
   462 				;PALNTS = $62	; 98 (XL) EUROPE/NORTH AMERICA TV FLAG
   463 				;LOGCOL = $63	; 99 LOGICAL LINE COLUMN POINTER
   464 				;MLTTMP = $66	;102
   465 				;OPNTMP = $66	;102 TEMPORARY STORAGE FOR CHANNEL OPEN
   466 				;SAVADR = $68	;104
   467 				;RAMTOP = $6A	;106 START OF ROM (END OF RAM + 1), HIGH BYTE ONLY
   468 				;
   469 				;BUFCNT = $6B	;107 BUFFER COUNT
   470 				;BUFSTR = $6C	;108 POINTER USED BY EDITOR
   471 				;BITMSK = $6E	;110 POINTER USED BY EDITOR
   472 				;SHFAMT = $6F	;111
   473 				;ROWAC  = $70	;112
   474 				;COLAC  = $72	;114
   475 				;ENDPT  = $74	;116
   476 				;DELTAR = $76	;118
   477 				;DELTAC = $77	;119
   478 				;ROWINC = $79	;121 (800)
   479 				;KEYDEF = $79	;121 (XL) KEY DEFINATION POINTER, 2 BYTES
   480 				;COLINC = $7A	;122 (800)
   481 				;SWPFLG = $7B	;123 NON 0 IF TEXT AND REGULAR RAM IS SWAPPED
   482 				;HOLDCH = $7C	;124 CH MOVED HERE BEFORE CTRL AND SHIFT
   483 				;INSDAT = $7D	;125
   484 				;COUNTR = $7E	;126
   485 				;;
   486 				;ZROFRE = $80	;128 FREE ZERO PAGE, 84 BYTES
   487 				;FPZRO  = $D4	;212 FLOATING POINT RAM, 43 BYTES
   488 				;FR0    = $D4	;212 FP REGISTER 0
   489 				;FRE    = $DA	;218
   490 				;FR1    = $E0	;224 FP REGISTER 1
   491 				;FR2    = $E6	;230 FP REGISTER 2
   492 				;FRX    = $EC	;236 SPARE
   493 				;EEXP   = $ED	;237 VALUE OF E
   494 				;NSIGN  = $ED	;237 SIGN OF FP NUMBER
   495 				;ESIGN  = $EF	;239 SIGN OF FP EXPONENT
   496 				;FCHFLG = $F0	;240 FIRST CHARACTER FLAG
   497 				;DIGRT  = $F1	;241 NUMBER OF DIGITS RIGHT OF DECIMAL POINT
   498 				;CIX    = $F2	;242 INPUT INDEX
   499 				;INBUFF = $F3	;243 POINTER TO ASCII FP NUMBER
   500 				;ZTEMP1 = $F5	;245
   501 				;ZTEMP4 = $F7	;247
   502 				;ZTEMP3 = $F9	;249
   503 				;DEGFLG = $FB	;251
   504 				;RADFLG = $FB	;251 0=RADIANS, 6=DEGREES
   505 				;FLPTR  = $FC	;252 POINTER TO BCD FP NUMBER
   506 				;FPTR2  = $FE	;254
   507 				;;
   508 				;;
   509 				;;	PAGE 1
   510 				;;
   511 				;;	65O2 STACK
   512 				;;
   513 				;;
   514 				;;
   515 				;;
   516 				;;	PAGE 2
   517 				;;
   518 				;;
   519 				;INTABS = $0200	;512 INTERRUPT RAM
   520 				;VDSLST = $0200	;512 NMI VECTOR
   521 				;VPRCED = $0202	;514 PROCEED LINE IRQ VECTOR
   522 				;VINTER = $0204	;516 INTERRUPT LINE IRQ VECTOR
   523 				;VBREAK = $0206	;518
   524 				;VKEYBD = $0208	;520
   525 				;VSERIN = $020A	;522 SERIAL INPUT READY IRQ
   526 				;VSEROR = $020C	;524 SERIAL OUTPUT READY IRQ
   527 				;VSEROC = $020E	;526 SERIAL OUTPUT COMPLETE IRQ
   528 				;VTIMR1 = $0210	;528 TIMER 1 IRQ
   529 				;VTIMR2 = $0212	;530 TIMER 2 IRQ
   530 				;VTIMR4 = $0214	;532 TIMER 4 IRQ
   531 				;VIMIRQ = $0216	;534 IRQ VECTOR
   532 				;CDTMV1 = $0218	;536 DOWN TIMER 1
   533 				;CDTMV2 = $021A	;538 DOWN TIMER 2
   534 				;CDTMV3 = $021C	;540 DOWN TIMER 3
   535 				;CDTMV4 = $021E	;542 DOWN TIMER 4
   536 				;CDTMV5 = $0220	;544 DOWN TIMER 5
   537 				;VVBLKI = $0222	;546
   538 				;VVBLKD = $0224	;548
   539 				;CDTMA1 = $0226	;550 DOWN TIMER 1 JSR ADDRESS
   540 				;CDTMA2 = $0228	;552 DOWN TIMER 2 JSR ADDRESS
   541 				;CDTMF3 = $022A	;554 DOWN TIMER 3 FLAG
   542 				;SRTIMR = $022B	;555 REPEAT TIMER
   543 				;CDTMF4 = $022C	;556 DOWN TIMER 4 FLAG
   544 				;INTEMP = $022D	;557 IAN'S TEMP
   545 				;CDTMF5 = $022E	;558 DOWN TIMER FLAG 5
   546 				;SDMCTL = $022F	;559 DMACTL SHADOW
   547 				;SDLSTL = $0230	;560 DISPLAY LIST POINTER
   548 				;SSKCTL = $0232	;562 SKCTL SHADOW
   549 				;;	 $0233	;563 (800) UNLISTED
   550 				;LCOUNT = $0233	;563 (XL) LOADER TEMP
   551 				;LPENH  = $0234	;564 LIGHT PEN HORIZONTAL
   552 				;LPENV  = $0235	;565 LIGHT PEN VERTICAL
   553 				;;	 $0236	;566 2 SPARE BYTES
   554 				;;	 $0238	;568 (800) SPARE, 2 BYTES
   555 				;RELADR = $0238	;568 (XL) LOADER
   556 				;CDEVIC = $023A	;570 DEVICE COMMAND FRAME BUFFER
   557 				;CAUX1  = $023C	;572 DEVICE COMMAND AUX 1
   558 				;CAUX2  = $023D	;573 DEVICE COMMAND AUX 2
   559 				;TEMP   = $023E	;574 TEMPORARY STORAGE
   560 				;ERRFLG = $023F	;575 DEVICE ERROR FLAG (EXCEPT TIMEOUT)
   561 				;DFLAGS = $0240	;576 FLAGS FROM DISK SECTOR 1
   562 				;DBSECT = $0241	;577 NUMBER OF BOOT DISK SECTORS
   563 				;BOOTAD = $0242	;578 BOOT LOAD ADDRESS POINTER
   564 				;COLDST = $0244	;580 COLD START FLAG, 1 = COLD START IN PROGRESS
   565 				;;	 $0245	;581 (800) SPARE
   566 				;RECLEN = $0245	;581 (XL) LOADER
   567 				;DSKTIM = $0246	;582 (800) DISK TIME OUT REGISTER
   568 				;;	;	;$0246	;582 (XL) RESERVED, 39 BYTES
   569 				;LINBUF = $0247	;583 (800) CHARACTER LINE BUFFER, 40 BYTES
   570 				;CHSALT = $026B	;619 (XL) CHARACTER SET POINTER
   571 				;VSFLAG = $026C	;620 (XL) FINE SCROLL TEMPORARY
   572 				;KEYDIS = $026D	;621 (XL) KEYBOARD DISABLE
   573 				;FINE   = $026E	;622 (XL) FINE SCROLL FLAG
   574 				;GPRIOR = $026F	;623 P/M PRIORITY AND GTIA MODES
   575 				;GTIA   = $026F	;623
   576 				;PADDL0 = $0270	;624 (XL) 3 MORE PADDLES, (800) 6 MORE PADDLES
   577 				;STICK0 = $0278	;632 (XL) 1 MORE STICK, (800) 3 MORE STICKS
   578 				;PTRIG0 = $027C	;636 (XL) 3 MORE PADDLE TRIGGERS, (800) 6 MORE
   579 				;STRIG0 = $0284	;644 (XL) 1 MORE STICK TRIGGER, (800) 3 MORE
   580 				;CSTAT  = $0288	;648 (800)
   581 				;WMODE  = $0289	;649
   582 				;BLIM   = $028A	;650
   583 				;;	;	;$028B	;651 5 SPARE BYTES
   584 				;NEWADR = $028E	;654 (XL)  LOADER RAM
   585 				;TXTROW = $0290	;656
   586 				;TXTCOL = $0291	;657
   587 				;TINDEX = $0293	;659 TEXT INDEX
   588 				;TXTMSC = $0294	;660
   589 				;TXTOLD = $0296	;662 OLD ROW AND OLD COL FOR TEXT, 2 BYTES
   590 				;;	;	;$0298	;664 4 SPARE BYTES
   591 				;TMPX1  = $029C	;668 (800)
   592 				;CRETRY = $029C	;668 (XL)  NUMBER OF COMMAND FRAME RETRIES
   593 				;SUBTMP = $029E	;670
   594 				;HOLD2  = $029F	;671
   595 				;DMASK  = $02A0	;672
   596 				;TMPLBT = $02A1	;673
   597 				;ESCFLG = $02A2	;674
   598 				;TABMAP = $02A3	;675 15 BYTE BIT MAP FOR TAB SETTINGS
   599 				;LOGMAP = $02B2	;690 4 BYTE LOGICAL LINE START BIT MAP
   600 				;INVFLG = $02B6	;694
   601 				;FILFLG = $02B7	;695 FILL DIRING DRAW FLAG
   602 				;TMPROW = $02B8	;696
   603 				;TMPCOL = $02B9	;697
   604 				;SCRFLG = $02BB	;699 SCROLL FLAG
   605 				;HOLD4  = $02BC	;700
   606 				;HOLD5  = $02BD	;701 (800)
   607 				;DRETRY = $02BD	;701 (XL)  NUMBER OF DEVICE RETRIES
   608 				;SHFLOC = $02BE	;702
   609 				;BOTSCR = $02BF	;703 24 NORM, 4 SPLIT
   610 				;PCOLR0 = $02C0	;704 3 MORE PLAYER COLOR REGISTERS
   611 				;COLOR0 = $02C4	;708 4 MORE GRAPHICS COLOR REGISTERS
   612 				;;	 $02C9	;713 (800) 23 SPARE BYTES
   613 				;RUNADR = $02C9	;713 (XL) LOADER VECTOR
   614 				;HIUSED = $02CB	;715 (XL) LOADER VECTOR
   615 				;ZHIUSE = $02CD	;717 (XL) LOADER VECTOR
   616 				;GBYTEA = $02CF	;719 (XL) LOADER VECTOR
   617 				;LOADAD = $02D1	;721 (XL) LOADER VECTOR
   618 				;ZLOADA = $02D3	;723 (XL) LOADER VECTOR
   619 				;DSCTLN = $02D5	;725 (XL) DISK SECTOR SIZ
   620 				;ACMISR = $02D7	;727 (XL) RESERVED
   621 				;KRPDER = $02D9	;729 (XL) KEY AUTO REPEAT DELAY
   622 				;KEYREP = $02DA	;730 (XL) KEY AUTO REPEAT RATE
   623 				;NOCLIK = $02DB	;731 (XL) KEY CLICK DISABLE
   624
   625 				;DMASAV = $02DD	;733 (XL) SDMCTL (DMA) SAVE
   626 				;PBPNT  = $02DE	;734 (XL) PRINTER BUFFER POINTER
   627 				;PBUFSZ = $02DF	;735 (XL) PRINTER BUFFER SIZE
   628 				;GLBABS = $02E0	;736 GLOBAL VARIABLES, 4 SPARE BYTES
   629 				;RAMSIZ = $02E4	;740 PERMANENT START OF ROM POINTER
   630 				;MEMTOP = $02E5	;741 END OF FREE RAM
   631 				;MEMLO  = $02E7	;743
   632 				;;	 $02E9	;745 (800) SPARE
   633 				;HNDLOD = $02E9	;745 (XL) HANDLER LOADER FLAG
   634 				;DVSTAT = $02EA	;746 DEVICE STATUS BUFFER, 4 BYTES
   635 				;CBAUDL = $02EE	;750 CASSETTE BAUD RATE, 2 BYTES
   636 				;CRSINH = $02F0	;752 1 = INHIBIT CURSOR
   637 				;KEYDEL = $02F1	;753 KEY DELAY AND RATE
   638 				;CH1    = $02F2	;754
   639 				;CHACT  = $02F3	;755
   640 				;CHBAS  = $02F4	;756 CHARACTER SET POINTER
   641 				;NEWROW = $02F5	;757 (XL) DRAW DESTINATION
   642 				;NEWCOL = $02F6	;758 (XL) DRAW DESTINATION
   643 				;ROWINC = $02F8	;760 (XL)
   644 				;COLINC = $02F9	;761 (XL)
   645 				;CHAR   = $02FA	;762
   646 				;ATACHR = $02FB	;763 ATASCII CHARACTER FOR CIO
   647 				;CH     = $02FC	;764
   648 				;FILDAT = $02FC	;764 COLOR FOR SCREEN FILL
   649 				;DSPFLG = $02FE	;766 DISPLAY CONTROL CHARACTERS FLAG
   650 				;SSFLAG = $02FF	;767 DISPLAY START/STOP FLAFG
   651 				;;
   652 				;;
   653 				;;	PAGE 3
   654 				;;
   655 				;;
   656 				;;	RESIDENT DISK HANDLER/SIO INTERFACE
   657 				;;
   658 				;DCB    = $0300	;768 DEVICE CONTROL BLOCK
   659 				;DDEVIC = $0300	;768
   660 				;DUNIT  = $0301	;769
   661 				;DCOMND = $0302	;770
   662 				;DSTATS = $0303	;771
   663 				;DBUFLO = $0304	;772
   664 				;DBUFHI = $0305	;773
   665 				;DTIMLO = $0306	;774
   666 				;DBYTLO = $0308	;776
   667 				;DBYTHI = $0309	;777
   668 				;DAUX1  = $030A	;778
   669 				;DAUX2  = $030B	;779
   670 				;TIMER1 = $030C	;780 INITIAL TIMER VALUE
   671 				;ADDCOR = $030E	;782 (800) ADDITION CORRECTION
   672 				;JMPERS = $030E	;782 (XL) OPTION JUMPERS
   673 				;CASFLG = $030F	;783 CASSETTE MODE WHEN SET
   674 				;TIMER2 = $0310	;784 FINAL VALUE, TIMERS 1 & 2 DETERMINE BAUD RATE
   675 				;TEMP1  = $0312	;786
   676 				;TEMP2  = $0313	;787 (XL)
   677 				;;TEMP2 = $0314	;788 (800)
   678 				;PTIMOT = $0314	;788 (XL) PRINTER TIME OUT
   679 				;TEMP3  = $0315	;789
   680 				;SAVIO  = $0316	;790 SAVE SERIAL IN DATA PORT
   681 				;TIMFLG = $0317	;791 TIME OUT FLAG FOR BAUD RATE CORRECTION
   682 				;STACKP = $0318	;792 SIO STACK POINTER SAVE
   683 				;TSTAT  = $0319	;793 TEMPORARY STATUS HOLDER
   684 				;HATABS = $031A	;794 HANDLER ADDRESS TABLE, 38 BYTES
   685 				;MAXDEV = $0321	;801 MAXIMUM HANDLER ADDRESS INDEX
   686 				;PUPBT1 = $033D	;829 (XL) POWER-UP/RESET
   687 				;PUPBT2 = $033E	;830 (XL) POWER-UP/RESET
   688 				;PUPBT3 = $033F	;831 (XL) POWER-UP/RESET
   689 				;;
   690 				;;IOCB's
   691 				;;
   692 				;IOCB   = $0340	;832
   693 				;ICHID  = $0340	;832
   694 				;ICDNO  = $0341	;833
   695 				;ICCOM  = $0342	;834
   696 				;ICSTA  = $0343	;835
   697 				;ICBAL  = $0344	;836
   698 				;ICBAH  = $0345	;837
   699 				;ICPTL  = $0346	;838
   700 				;ICPTH  = $0347	;839
   701 				;ICBLL  = $0348	;840
   702 				;ICBLH  = $0349	;841
   703 				;ICAX1  = $034A	;842
   704 				;ICAX2  = $034B	;843
   705 				;ICAX3  = $034C	;844
   706 				;ICAX4  = $034D	;845
   707 				;ICAX5  = $034E	;846
   708 				;ICAX6  = $034F	;847
   709 				;;		 OTHER IOCB's, 112 BYTES
   710 				;
   711 				;PRNBUF = $03C0	;960 PRINTER BUFFER, 40 BYTES
   712 				;;	 $03E8	;1000 (800) 21 SPARE BYTES
   713 				;SUPERF = $03E8	;1000 (XL) SCREEN EDITOR
   714 				;CKEY   = $03E9	;1001 (XL) START KEY FLAG
   715 				;CASSBT = $03EA	;1002 (XL) CASSETTE BOOT FLAG
   716 				;CARTCK = $03EB	;1003 (XL) CARTRIDGE CHECKSUM
   717 				;ACMVAR = $03ED	;1005 (XL) RESERVED, 6 BYTES
   718 				;MINTLK = $03F9	;1017 (XL) RESERVED
   719 				;GINTLK = $03FA	;1018 (XL) CARTRIDGE INTERLOCK
   720 				;CHLINK = $03FB	;1019 (XL) HANDLER CHAIN, 2 BYTES
   721 				;CASBUF = $03FD	;1021 CASSETTE BUFFER, 131 BYTES TO $047F
   722 				;;
   723 				;;
   724 				;;	PAGE 4
   725 				;;
   726 				;;
   727 				;USAREA = $0480	;1152 128 SPARE BYTES
   728 				;;
   729 				;;	SEE APPENDIX C FOR PAGES 4 AND 5 USAGE
   730 				;;
   731 				;;
   732 				;;
   733 				;;
   734 				;;	PAGE 5
   735 				;;
   736 				;PAGE5  = $0500	;1280 127 FREE BYTES
   737 				;;	 $057E	;1406 129 FREE BYTES IF FLOATING POINT ROUTINES
   738 				;NOT USED
   739 				;;
   740 				;;FLOATING POINT NON-ZERO PAGE RAM, NEEDED ONLY IF FP IS USED
   741 				;;
   742 				;LBPR1  = $057E	;1406 LBUFF PREFIX 1
   743 				;LBPR2  = $05FE	;1534 LBUFF PREFIX 2
   744 				;LBUFF  = $0580	;1408 LINE BUFFER
   745 				;PLYARG = $05E0	;1504 POLYNOMIAL ARGUMENTS
   746 				;FPSCR  = $05E6	;1510 PLYARG+FPREC
   747 				;FPSCR1 = $05EC	;1516 FPSCR+FPREC
   748 				;FSCR   = $05E6	;1510 =FPSCR
   749 				;FSCR1  = $05EC	;1516 =FPSCR1
   750 				;LBFEND = $05FF	;1535 END OF LBUFF
   751 				;;
   752 				;;
   753 				;;	PAGE 6
   754 				;;
   755 				;;
   756 				;PAGE6  = $0600	;1536 256 FREE BYTES
   757 				;;
   758 				;;
   759 				;;	PAGE 7
   760 				;;
   761 				;;
   762 				;BOOTRG = $0700	;1792 PROGRAM AREA
   763 				;;
   764 				;;
   765 				;;	UPPER ADDRESSES
   766 				;;
   767 				;;
   768 				;RITCAR = $8000	;32768 RAM IF NO CARTRIDGE
   769 				;LFTCAR = $A000	;40960 RAM IF NO CARTRIDGE
   770 				;;C0PAGE= $C000	;49152 (800) EMPTY, 4K BYTES
   771 				;C0PAGE = $C000	;49152 (XL) 2K FREE RAM IF NO CARTRIDGE
   772 				;;	 $C800	;51200 (XL) START OF OS ROM
   773 				;CHORG2 = $CC00	;52224 (XL) INTERNATIONAL CHARACTER SET
   774 				;;
   775 				;;
   776 				;;	HARDWARE REGISTERS
   777 				;;
   778 				;;
   779 				;;	SEE REGISTER LIST FOR MORE INFORMATION
   780 				;;
   781 				;;
   782 				;HPOSP0 = $D000	;53248
   783 				;M0PF   = $D000	;53248
   784 				;SIZEP0 = $D008	;53256
   785 				;M0PL   = $D008	;53256
   786 				;SIZEM  = $D00C	;53260
   787 				;GRAFP0 = $D00D	;53261
   788 				;GRAFM  = $D011	;53265
   789 				;COLPM0 = $D012	;53266
   790 				;COLPF0 = $D016	;53270
   791 				;PRIOR  = $D01B	;53275
   792 				;GTIAR  = $D01B	;53275
   793 				;VDELAY = $D01C	;53276
   794 				;GRACTL = $D01D	;53277
   795 				;HITCLR = $D01E	;53278
   796 				;CONSOL = $D01F	;53279
   797 				;AUDF1  = $D200	;53760
   798 				;AUDC1  = $D201	;53761
   799 				;AUDCTL = $D208	;53768
   800 				;RANDOM = $D20A	;53770
   801 				;IRQEN  = $D20E	;53774
   802 				;SKCTL  = $D20F	;53775
   803 				;PORTA  = $D300	;54016
   804 				;PORTB  = $D301	;54017
   805 				;PACTL  = $D302	;54018
   806 				;PBCTL  = $D303	;54019
   807 				;DMACLT = $D400	;54272
   808 				;DLISTL = $D402	;54274
   809 				;HSCROL = $D404	;54276
   810 				;VSCROL = $D405	;54277
   811 				;CHBASE = $D409	;54281
   812 				;WSYNC  = $D40A	;54282
   813 				;VCOUNT = $D40B	;54283
   814 				;NMIEN  = $D40E	;54286
   815 				;
   816 				;;
   817 				;;
   818 				;;	FLOATING POINT MATH ROUTINES
   819 				;;
   820 				;;
   821 				;
   822 				;AFP    = $D800	;55296
   823 				;FASC   = $D8E6	;55526
   824 				;IFP    = $D9AA	;55722
   825 				;FPI    = $D9D2	;55762
   826 				;ZFR0   = $DA44	;55876
   827 				;ZF1    = $DA46	;55878
   828 				;FSUB   = $DA60	;55904
   829 				;FADD   = $DA66	;55910
   830 				;FMUL   = $DADB	;56027
   831 				;FDIV   = $DB28	;56104
   832 				;PLYEVL = $DD40	;56640
   833 				;FLD0R  = $DD89	;56713
   834 				;FLD0P  = $DD8D	;56717
   835 				;FLD1R  = $DD98	;56728
   836 				;FLD1P  = $DD9C	;56732
   837 				;FSTOR  = $DDA7	;56743
   838 				;FSTOP  = $DDAB	;56747
   839 				;FMOVE  = $DDB6	;56758
   840 				;EXP    = $DDC0	;56768
   841 				;EXP10  = $DDCC	;56780
   842 				;LOG    = $DECD	;57037
   843 				;LOG10  = $DED1	;57041
   844 				;
   845 				;;
   846 				;;
   847 				;;	OPERATING SYSTEM
   848 				;;
   849 				;;
   850 				;;	MODULE ORIGIN TABLE
   851 				;;
   852 				;CHORG  = $E000	;57344 CHARACTER SET, 1K
   853 				;VECTBL = $E400	;58368 VECTOR TABLE
   854 				;VCTABL = $E480	;58496 RAM VECTOR INITIAL VALUE TABLE
   855 				;CIOORG = $E4A6	;58534 CIO HANDLER
   856 				;INTORG = $E6D5	;59093 INTERRUPT HANDLER
   857 				;SIOORG = $E944	;59716 SIO DRIVER
   858 				;DSKORT = $EDEA	;60906 DISK HANDLER
   859 				;PRNORG = $EE78	;61048 PRINTER HANDLER
   860 				;CASORG = $EE78	;61048 CASSETTE HANDLER
   861 				;MONORG = $F0E3	;61667 MONITOR/POWER UP MODULE
   862 				;KBDORG = $F3E4	;62436 KEYBOARD/DISPLAY HANDLER
   863 				;;
   864 				;;
   865 				;;  VECTOR TABLE, CONTAINS ADDRESSES OF CIO ROUTINES IN THE
   866 				;;  FOLLOWING ORDER. THE ADDRESSES IN THE TABLE ARE TRUE ADDRESSES-1
   867 				;;
   868 				;;  ADDRESS + 0  OPEN
   869 				;;	   + 2  CLOSE
   870 				;;	   + 4  GET
   871 				;;	   + 6  PUT
   872 				;;	   + 8  STATUS
   873 				;;	   + A  SPECIAL
   874 				;;	   + C  JMP TO INITIALIZATION
   875 				;;	   + F  NOT USED
   876 				;;
   877 				;;
   878 				;EDITRV = $E400	;58368 EDITOR
   879 				;SCRENV = $E410	;58384 SCREEN
   880 				;KEYBDV = $E420	;58400 KEYBOARD
   881 				;PRINTV = $E430	;58416 PRINTER
   882 				;CASETV = $E440	;58432 CASSETTE
   883 				;;
   884 				;;	ROM VECTORS
   885 				;;
   886 				;DSKINV = $E453	;58451
   887 				;CIOV   = $E456	;58454
   888 				;SIOV   = $E459	;58457
   889 				;SYSVBV = $E45F	;58463
   890 				;VBIVAL = $E460	;58464 ADR AT VVBLKI
   891 				;XITVBV = $E462	;58466 EXIT VBI
   892 				;VBIXVL = $E463	;58467 ADR AT VVBLKD
   893 				;BLKBDV = $E471	;58481 MEMO PAD MODE
   894 				;WARMSV = $E474	;58484
   895 				;COLDSV = $E477	;58487
   896
   100 					icl "CartMenu-Definitions.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Definitions.asm
     1 				;
     2 				;	>>> The!Cart Menu - Cartmenu definitions by hias <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 				; The following jump vectors ar available in bank 0 of the "cartmenu.rom".
     7 				; See "cartmenu.src" of the "http://www.horus.com/~hias/thecart/software/".
     8 				;
     9 				;$A000: Start CartMenu - ruft "mein" CartMenu auf
    10 				;
    11 				;$A003: Start Cartridge - einfach A mit dem Mode, X mit dem
    12 				;Low-Byte der Banknummer und Y mit dem High-Byte der Banknummer
    13 				;laden und dort hin springen und die Cart wird gestartet.
    14 				;
    15 				;$A006: Read SPI EEPROM
    16 				;$A009: Write SPI EEPROM
    17 				;
    18 				;Der ZP Vektor in $E0/$E1 muß auf die zu lesenden/schreibenden Daten
    19 				;zeigen, X den Byte-Count und Y die Adresse im EEPROM enthalten.
    20 				;Bei einem Fehler ist nach dem Return das Carry-Flag gesetzt
    21 				;(cleared bei OK).
    22 				;
    23 				;Beim Schreiben von Daten musst Du folgendes beachten: Das EEPROM
    24 				;ist intern in Blöcken zu 16-Bytes organisiert und der interne
    25 				;Adress-Zähler kann diese Grenzen nicht überschreiten (er macht
    26 				;dann einen wrap-around).
    27 				;
    28 				;Schreibst Du zB 3 Bytes ab Adresse 14, so landen die in den
    29 				;Adressen 14, 15, 0.
    30 				;
    31 				;Also am besten immer max. 16 Bytes schreiben und aufpassen, daß
    32 				;Du keine 16-Byte Grenze überschreitest.
    33 				;Wie's beim Lesen aussieht hab' ich noch nicht getestet, aber
    34 				;lieber aufpassen und kleine Häppchen schreiben :)
    35 				;Achja: Das CartMenu verwendet die EEPROM Adressen ab $F0, der Rest
    36 				;darunter ist frei.
    37 				;
    38 				;$A00C: Init OS Variables
    39 				;
    40 				;Das CartMenu wird per Cart-Init gestartet, zu diesem Zeitpunkt
    41 				;ist noch kein GR.0 Bildschirm geöffnet und einige Variablen im
    42 				;OS Bereich sind noch nicht wie gewohnt initialisiert.
    43 				;
    44 				;Wenn Du die Cart Start/Init Adressen verbiegst, mach am besten
    45 				;einen JSR dorthin, damit der Zeichensatz richtig gesetzt ist
    46 				;und Keyboard/Break IRQ und NMI aktiviert sind. Danach sollte
    47 				;alles wie üblicherweise gewohnt laufen.
    48 				;
    49 				; $A00F: default cartridge start address
    50 				;
    51 				; Einsprungpunkt zum default The!Cart Menü Start bei $A00F,
    52 				; zeigt per Default auf mein expert Menü kann von Peters Menü
    53 				; verbogen werden. Die Cart Init/Start Vektoren bei $BFFx zeigen
    54 				; nun auf diesen Einsprungpunkt.
    55 				;
    56 				; $A012: Start cartridge at specific address
    57 				;
    58 				; A=mode, X=bank lo, Y=bank hi, C=lockflag, E0/E1: start address
    59 				; Start is performed with NMI and IRQs off.
    60
    61 					.enum cartmenu		;HIAS Simple Menu (cartmenu.rom)
    62 = 00E0			runadr			= $e0	;Run address for entry_runcart_adr
    63 = 00E2			spivec			= $e2	;SPI EEPROM zero page vector
    64 = A000			entry_cartmenu		= $a000	;Start cartmenu
    65 = A003			entry_runcart		= $a003	;Start cartridge, IN: <A>=mode, <X>=bank lo, <Y>=bank hi, <C>=lockflag
    66 = A006			entry_read_eeprom	= $a006 ;Read SPI EEPROM, IN: (SPIVEC)=data, <X>=byte count, <Y>=EEPROM address
    67 = A009			entry_write_eeprom	= $a009 ;Write SPI EEPROM, IN: (SPIVEC)=data, <X>=byte count, <Y>=EEPROM address
    68 = A00C			entry_initos		= $a00c	;Init OS Variables
    69 = A00F			entry_default_cartstart	= $a00f	;Default cartride start vector used by the flasher, set to cartmenu or extended menu, depending on which is available
    70 = A012			entry_runcart_adr	= $a012	;Start cartridge, IN: <A>=mode, <X>=bank lo, <Y>=bank hi, <C>=lockflag, <runadr>=run address
    71 					.ende
    72 					
    73 					.enum the_cart_mode	;Special The!Cart mode value used by the studio.
    74 = 0001			tc_mode_8k		= $01
    75 = 0020			tc_mode_flexi		= $20
    76 = 00E0			tc_mode_binary_file	= $e0
    77 = 00E1			tc_mode_executable_file = $e1;	
    78 = 00E2			tc_mode_atr_file	= $e2
    79 					.ende
    80 					
    81 					.enum the_cart
    82 = D5A0			primary_bank_lo		= $d5a0
    83 = D5A1			primary_bank_hi		= $d5a1
    84 = D5A2			primary_bank_enable	= $d5a2
    85 = D5A3			secondary_bank_lo	= $d5a3
    86 = D5A4			secondary_bank_hi	= $d5a4
    87 = D5A5			secondary_bank_enable	= $d5a5
    88 = D5A6			mode			= $d5a6
    89 = D5AF			configuration_lock	= $d5af
    90 					.ende
    91
    92
   101
   102 				;===============================================================
   103
   104 					opt h-f+
   105
   106 					org module_a000			;Cartmenu part 1, simple menu
   107 					.local cartmenu_rom_part1 	;Always use latest "cartmenu.rom" which is also used in the studio
   108 A000 4C 6D A7 4C 07 AD + 	ins "..\..\src\data\cartmenu.rom",+0,$1800
   109 					.endl
   110
   111 				;===============================================================
   112
   113 B800				org menu_atr_rom		;Resident callbacks for the ATR simulation
   114
   115 B800				icl "atr/TheMenu-ATR-Starter-ROM.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter-ROM.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=../CartMenu-Extended.asm
     5 				;
     6 				;	The definition in this file are used by both the RAM and the ROM part of the ATR started
     7
     8 B800				.proc start_atr_file_rom	;Starter ROM part, must be completely within the first bank
     9
    10 B800				icl "TheMenu-ATR-Starter-Globals.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter-Globals.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=../CartMenu-Extended.asm
     5 				;
     6 				;	The definition in this file are used by both the RAM and the ROM part of the ATR started.
     7 				;	Only zero page locations used by DISKIN/SIOV must be used.
     8 				;	Using zero page locations usde by CIO will break DOS like access.
     9
    10 = 0000			selected_item_number	= $00	;Byte, used in patched ATR file menus, see AtrLoader.java
    11 = 0004			bootini    		= $04	;Word, same as in OS boot process
    12 = 000C			dosini	   		= $0c	;Word, same as in OS boot process
    13 = 0015			buffer_ptr		= $15	;Word, BUFADR, normally used by DSKINV
    14 = 0032			cart_start_bank		= $32	;Word, BFENLO, normally used by SIOV
    15 = 0034			cart_bank  		= $34	;Word, BFENLO, normally used by SIOV
    16 = 0036			cart_ptr  		= $36	;Word, LTEMP, normally used by SIOV
    17 = 0038			buffer_len		= $38	;Byte, BUFRFL, normally used by SIOV
    18 = 0039			empty_dl   		= $39	;3 bytes, RECVDN/XMTDON/CHKSNT, normally used by SIOV
    19 = 0043			fmszpg			= $43	;6 bytes reserved for the File Managing System (FMS)
    20 = 0700			boot_buffer 		= $700
    11
    12 				;===============================================================
    13
    14 B800				.proc special_sio		;IN: <A>=disk status (dvstat), <X>=start bank low, <Y>=start bank hi
    15 									;OUT: cart_bank (word), cart_ptr(word), buffer_ptr (word), buffer_len (word), <C>=0 to perform normal sector loading, <C>=1 to return SIO status returned in in <Y>
    16
    17 = 0038				dvstat_temp   = buffer_len	;Byte, reuse buffer_len it will only be used later
    18 = 0015				sector_number = buffer_ptr	;Word, reuse buffer_ptr because it will only be used later
    19
    20 B800 85 38			sta dvstat_temp			;Bit 7=1 means disk is ED, bit 5=1 means disk is DD
    21 B802 86 32			stx cart_start_bank
    22 B804 84 33			sty cart_start_bank+1
    23 					
    24 B806 AD 01 03			lda dunit			;Is device number "D1:"?
    25 B809 C9 01			cmp #1
    26 B80B F0 04			beq device_d1
    27 B80D A0 82			ldy #130			;No, return error 130 - Nonexistent Device
    28 B80F 38				sec
    29 B810 60				rts
    30
    31 B811			device_d1
    32 B811 AD 02 03			lda dcomnd			;Is command "R"read sector?
    33 B814 C9 52			cmp #'R'
    34 B816 F0 08			jeq command_read		;Yes
    35 B818 C9 53			cmp #'S'			;Is command "S"tatus?
    36 B81A F0 6B			jeq command_status
    37 B81C A0 84			ldy #132			;No, return error 132 - Unknown command
    38 B81E 38				sec
    39 B81F 60				rts
    40
    41 				;===============================================================
    42
    43 B820				.proc command_read
    44
    45 B820				.proc compute_cart_adr		;Compute cart_adr and sector_number (as 128 byte sector with linear layout)
    46
    47 B820 AD 0A 03			lda daux1
    48 B823 AC 0B 03			ldy daux2
    49 B826 85 15			sta sector_number
    50 B828 84 16			sty sector_number+1
    51
    52 B82A AE 09 03			ldx dbythi			;Double density?
    53 B82D F0 19			beq no_dd			;No, high byte of number of bytes to transfer is 0
    54 B82F C0 00			cpy #0				;Sectors 256, ... have 256 bytes in DD
    55 B831 D0 04			bne is_dd
    56 B833 C9 04			cmp #4				;Sectors 1,2,3 have 128 bytes even in DD
    57 B835 90 11			bcc no_dd
    58 B837 E9 04		is_dd	sbc #4				;<C>==1
    59 B839 B0 02			scs
    60 B83B C6 16			dec sector_number+1
    61 B83D 0A				asl
    62 B83E 26 16			rol sector_number+1
    63 B840 69 04			adc #4				;<C>==0
    64 B842 90 02			scc
    65 B844 E6 16			inc sector_number+1
    66 B846 85 15			sta sector_number
    67 B848			no_dd
    68 B848 A5 16			lda sector_number+1		;Set cart_ptr = sector_number*$100/2 = (daux1,2)*$80
    69 B84A 4A				lsr
    70 B84B A5 15			lda sector_number
    71 B84D 6A				ror
    72 B84E 29 1F			and #$1f			;Mask high byte to to $a000-$bfff
    73 B850 09 A0			ora #$a0
    74 B852 85 37			sta cart_ptr+1			;Store address, hi
    75
    76 B854 A9 00			lda #0
    77 B856 6A				ror
    78 B857 85 36			sta cart_ptr			;Store address, lo
    79 					.endp
    80
    81 B859				.proc compute_start_bank_number
    82 B859 A5 16			lda sector_number+1		;Set cart_bank = sector_number/(8192/128) =  sector_number/64
    83 B85B 85 35			sta cart_bank+1
    84 B85D A5 15			lda sector_number
    85 B85F A0 06			ldy #6
    86 B861			shift_loop
    87 B861 46 35			lsr cart_bank+1
    88 B863 6A				ror
    89 B864 88				dey
    90 B865 D0 FA			bne shift_loop
    91 B867 85 34			sta cart_bank
    92
    93 B869 18 A5 32 65 34 85 + 	adw cart_start_bank cart_bank cart_bank
    94 					.endp				;End of compute_start_bank_number
    95
    96 B876 AD 04 03 85 15 AD + 	mwa dbuflo buffer_ptr		;Set buffer_ptr to target address
    97 B880 AD 08 03 85 38		mva dbytlo buffer_len		;Copy number of bytes to ZP
    98 B885 18				clc				;OUT: cart_bank (word), cart_ptr (word), buffer_ptr (word), buffer_len (word), <C>=0 to perform normal sector loading
    99 B886 60				rts
   100 					
   101 					.endp				;End of command_read
   102
   103 				;===============================================================
   104
   105 B887				.proc command_status		;Process "S"tatus command
   106 B887 A5 38 8D EA 02		mva dvstat_temp dvstat
   107 B88C A9 00			lda #0
   108 B88E 8D EB 02			sta dvstat+1			;Clear remaining status bytes.
   109 B891 8D EC 02			sta dvstat+2
   110 B894 8D ED 02			sta dvstat+3
   111 B897 A0 01			ldy #1
   112 B899 38				sec
   113 B89A 60				rts
   114 					.endp				;End of command_status
   115
   116 				;===============================================================
   117
   118 					.endp				;End of special_sio
   119
   120 					.endp				;End of start_atr_file_rom
   121 					
   122 B89B				m_assert_align start_atr_file_rom bank_size
Macro: M_ASSERT_ALIGN [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "START_ATR_FILE_ROM within ",BANK_SIZE," boundary between ", START_ATR_FILE_ROM, " - ", START_ATR_FILE_ROM + .len START_ATR_FILE_ROM - 1
     8 				START_ATR_FILE_ROM within $2000 boundary between $B800 - $B89A
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter-ROM.asm
   123 					
   116
   117 				;===============================================================
   118
   119 B89B				org menu_start_rom		;First entry vector on power up, called from simple menu startup sequence
   120
   121 BE00				.proc menu_start
   122
   123 BE00 20 4E BE			jsr check_reset_button
   124
   125 				;	Init normal screen etc. while bank 0 is active
   126 BE03 D8				cld
   127 BE04 20 0C A0			jsr cartmenu.entry_initos
   128 BE07 A9 FF			lda #$ff
   129 BE09 8D 44 02			sta coldst			;RESET triggers coldstart by default
   130 BE0C 8D 01 D3			sta portb			;Disable BASIC ROM in MMU on XL machines
   131 BE0F A9 01 8D F8 03		mva #$01 basicf			;Ensure it's not enabled during warmstart
   132 				;       TODO: On an Atari 800 this does not work!
   133 BE14 A9 C0			lda #$c0			;Use RAM in cartridge area in XL machines
   134 BE16 85 6A			sta ramtop			;Change the values used by the graphics screen
   135 BE18 8D E4 02			sta ramsiz			;The memtop for the physical RAM must not be changed
   136
   137 				;	Copy menu control block to zeropage RAM
   138 				;	Copy menu loader to RAM
   139 BE1B A2 00			ldx #0
   140 BE1D			copy_menu_mcb
   141 BE1D E0 34			cpx #menu_mcb_size
   142 BE1F B0 05			bcs copy_menu
   143 BE21 BD 00 BF			lda menu_mcb_rom,x
   144 BE24 95 A0			sta menu_mcb_zp,x
   145 BE26			copy_menu
   146 BE26 BD 00 BE			lda menu_start_rom,x
   147 BE29 9D 00 07			sta menu_start_ram,x
   148 BE2C E8				inx
   149 BE2D D0 EE			bne copy_menu_mcb
   150
   151 				;	Setup bank switching routine based on flash target class by setting the low byte of the JMP vector
   152 BE2F A5 A0			lda menu_mcb.cartridge_type
   153 BE31 A2 D9			ldx #<menu_core.set_bank.set_bank_atmax_1024
   154 BE33 C9 2A			cmp #cartridge_type.CARTRIDGE_ATMAX_1024
   155 BE35 F0 11			beq setup_cartridge_type
   156
   157 				;	All The!Cart versions are mapped to the same routine which checks for the maximum high bank 64
   158 				;	The check could be more precise, but there's no enough space in this first page for it
   159 BE37 A2 E1			ldx #<menu_core.set_bank.set_bank_thecart_128m
   160 BE39 C9 41			cmp #cartridge_type.CARTRIDGE_THECART_32M
   161 BE3B F0 0B			beq setup_cartridge_type
   162 BE3D C9 42			cmp #cartridge_type.CARTRIDGE_THECART_64M
   163 BE3F F0 07			beq setup_cartridge_type
   164 BE41 C9 3E			cmp #cartridge_type.CARTRIDGE_THECART_128M
   165 BE43 F0 03			beq setup_cartridge_type
   166
   167 BE45 A9 44			lda #$44
   168 BE47				jam
Macro: JAM [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 BE47 02				.byte $02
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Extended.asm
   169
   170 BE48			setup_cartridge_type			;IN: <X>=low byte of set_bank_routine, <Y>=(maximum high byte of bank number)+1
   171 BE48 8E D7 07			stx menu_core.set_bank.jump_adr
   172
   173 BE4B 4C 75 07			jmp menu_core.copy_menu_init
   174
   175 				;===============================================================
   176
   177 BE4E				.proc check_reset_button	;Cartridge RESET button still pressed?
   178 BE4E 78				sei				;Disable VBI stage 2
   179 BE4F A9 01			lda #1
   180 BE51 8D A5 D5			sta the_cart.secondary_bank_enable ;Try to enable secondary bank window
   181 BE54 AD A5 D5			lda the_cart.secondary_bank_enable ;Forced to zero by RESET button?
   182 BE57 D0 15			bne can_start
   183 BE59			cannot_restart
   184 BE59 AD 0B D4 8D 1A D0		mva vcount colbk
   185 BE5F A9 01			lda #1				;Cartridge RESET button released?
   186 BE61 8D A5 D5			sta the_cart.secondary_bank_enable
   187 BE64 AD A5 D5			lda the_cart.secondary_bank_enable
   188 BE67 F0 F0			beq cannot_restart
   189 BE69 A9 00			lda #0
   190 BE6B 8D A5 D5			sta the_cart.secondary_bank_enable	
   191 BE6E			can_start
   192 BE6E A9 00			lda #0
   193 BE70 8D A5 D5			sta the_cart.secondary_bank_enable
   194 BE73 58				cli				;Enable VBI stage 2
   195 BE74 60				rts
   196 					.endp				;End of check_reset_button
   197
   198 					.endp				;menu_start
   199
   200 				;===============================================================
   201
   202 				;	Relocate copy routine to RAM area
   203 					opt f-
   204 BE75				org *-menu_start_rom+menu_start_ram
   205 					opt f+
   206
   207 0775				.proc menu_core
   208
   209 				;===============================================================
   210
   211 0775				.proc copy_menu_init	;Copy complete menu from cartridge to RAM
   212
   213 0775 78				sei			;Disable all interrupts
   214 0776 A9 00			lda #0
   215 0778 8D 0E D2			sta irqen
   216 077B 8D 0E D4			sta nmien
   217
   218 077E A9 08 8D D3 07 A9 + 	mwa #menu_start_bank copy_banks.bank_number
   219 0788 A9 01 8D D5 07		mva #[.len extended_menu+bank_size-1]/bank_size copy_banks.bank_count
   220 078D A9 08 85 83			mva #>menu_main_ram p2+1
   221 0791 20 A2 07			jsr copy_banks
   222
   223 0794 A9 40			lda #$40		;Enable all interrupts again
   224 0796 8D 0E D4			sta nmien
   225 0799 A9 C0			lda #$c0
   226 079B 8D 0E D2			sta irqen
   227 079E 58				cli
   228 079F 4C 00 08			jmp menu_main_ram
   229
   230
   231 				;===============================================================
   232
   233 07A2				.proc copy_banks	;Copy full banks from $a000 to (p2)
   234 07A2				.var .word bank_number, .byte bank_count
   235
   236 07A2			copy_bank
   237 07A2 AE D3 07			ldx bank_number
   238 07A5 AC D4 07			ldy bank_number+1
   239 07A8 20 D6 07			jsr set_bank
   240
   241 07AB A2 20			ldx #>bank_size
   242 07AD A0 00			ldy #0
   243 07AF 84 80			sty p1
   244 07B1 84 82			sty p2
   245 07B3 A9 A0 85 81			mva #>module_a000 p1+1
   246 07B7			copy_page
   247 07B7 B1 80			lda (p1),y
   248 07B9 91 82			sta (p2),y
   249 07BB C8				iny
   250 07BC D0 F9			bne copy_page
   251 07BE E6 81			inc p1+1
   252 07C0 E6 83			inc p2+1
   253 07C2 CA				dex
   254 07C3 D0 F2			bne copy_page
   255 07C5 EE D3 07 D0 03 EE + 	inw bank_number
   256 07CD CE D5 07			dec bank_count
   257 07D0 D0 D0			bne copy_bank
   258 07D2 60				rts
   259 = 07D3 00 00		BANK_NUMBER
   259 = 07D5 00		BANK_COUNT
   259 					.endp				;End of copy_banks
   260
   261 					.endp				;End copy_menu_init
   262
   263 				;===============================================================
   264
   265 07D6				.proc set_bank			;IN: <X>=Bank lo, <Y>=Bank hi
   266 = 07D7			jump_adr = *+1
   267 07D6 4C D6 07			jmp set_bank			;Lo bytes is adapted by initialization
   268
   269 07D9				.proc set_bank_atmax_1024
   270 07D9 9D 00 D5			sta $d500,x
   271 07DC C0 01			cpy #1
   272 07DE B0 0C			bcs bank_error
   273 07E0 60				rts
   274 					.endp				;End of set_bank_maxflash
   275
   276 07E1				.proc set_bank_thecart_128m
   277 07E1 8E A0 D5			stx the_cart.primary_bank_lo		;Set primary bank register low byte (0-255, default: 0)
   278 07E4 8C A1 D5			sty the_cart.primary_bank_hi		;Set primary bank register high byte (0-63, default: 0)
   279 				;	n/a the_cart.primary_bank_enable	;Set primary bank enable (1=enable, 0=disable, default: 1)
   280 = 07E8			max_bank =*+1
   281 07E7 C0 40			cpy #64
   282 07E9 B0 01			bcs bank_error
   283 07EB 60				rts
   284 					.endp				;End of set_bank_thecart
   285
   286 07EC				.proc bank_error		;Invalid bank value used
   287 07EC A9 34			lda #$34
   288 07EE 8D C8 02			sta color4
   289 07F1 8D 1A D0			sta colbk
   290 07F4 02				.byte 2
   291 					.endp				;End of bank_error
   292
   293 					.endp				;End of set_bank
   294
   295
   296 07F5				.proc get_bank			;OUT: <X>=Bank lo, <Y>=Bank hi
   297
   298 07F5			 	.proc get_bank_thecart_128m
   299 07F5 AE A0 D5			ldx the_cart.primary_bank_lo
   300 07F8 AC A1 D5			ldy the_cart.primary_bank_hi
   301 07FB 60				rts
   302 					.endp
   303
   304 					.endp
   305
   306 07FC				.proc disable_bank
   307 					.endp
   308
   309 				;===============================================================
   310
   311 07FC				org menu_start_ram+$ff		;Align to full page
   312 07FF 00				.byte 0
   313
   314 					.endp				;End of menu_core
   315 				;===============================================================
   316
   317 					opt f-
   318 					org menu_mcb_rom		;Filled by The!Cart Studio during export
   319 					opt f+
   320 BF00 2A 00			.word cartridge_type.CARTRIDGE_ATMAX_1024	;flash_target_class
   321 BF02 01 00			.word 1				;bank_count
   322 BF04 01 00			.word 1				;menu_entries_count
   323 BF06 0B 00			.word 11			;menu_entries_start_bank_number
   324 BF08 30 31 32 33 34 35 + 	.byte '0123456789012345678901234567890123456789'
   325
   326 				;===============================================================
   327
   328 					org menu_signature		;16 reserved bytes
   329
   330 				;===============================================================
   331
   332 					org $bff0			;Entered from other banks during startup
   333
   334 BFF0				.proc menu_foreign_init	
   335 BFF0 A9 00			lda #0
   336 BFF2 8D 00 D5			sta $d500			;Activate bank 0 of AtariMax carts
   337 BFF5 6C FE BF			jmp ($bffe)
   338 BFF8 EA				nop
   339 BFF9 EA				nop
   340 					.endp
   341
   342 					org $bffa			;Cartridge control block
   343 BFFA 00 BE 00 04 00 BE		.byte a(menu_start_rom),$00,$04,a(menu_start_rom)
   344
   345 				;===============================================================
   346
   347 					opt f-
   348 					org module_a000			;Cartmenu part 2, Flasher and MyPicoDos
   349 A000				.local cartmenu_rom_part2
   350 A000 4C 8B 16 81 00 4C + 	ins "..\..\src\data\cartmenu.rom",+$2000,$8000
   351
   352 				;	24k of dummy data reserved for future use by HIAS
   353 					opt f-
   354 012000				org $0000
   355 					opt f+
   356 0000				org $5fff
   357 5FFF FF				.byte $ff
   358 					.endl
   359
   360 				;===============================================================
   361
   362 					opt f-
   363 					org menu_main_ram		;Extended Menu Code, 24k, $6000 bytes
   364 					opt f+
   365
   366 0800				icl "TheMenu.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
     1
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;	Make sure the latest version of "cartmenu.rom" is in the "/src/data" folder.
     4 				;
     5 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     6
     7 0800				.proc extended_menu
     8
     9 = 0028			screen_width	= 40
    10 = 0019			screen_lines	= 25
    11
    12 = 0014			result_lines	= 20
    13 = 3050			result_sm	= sm+screen_width*2
    14
    15
    16 = 3400			genres_list 	  = menu_data_start	;Up to menu_mcb.menu_genres_count addresses (lo/hi) of the genre names followed by the genre names, $400 bytes 
    17 = 3800			genre_sm	  = genres_list+$400	;Screen memory for the genre line, $400 bytes
    18 = 3C00			found_entries	  = genre_sm+$400	;Numbers (lo/hi) of entries that have been found, 16384*2 = 32768 bytes
    19 = 9FFF			found_entries_end = menu_data_end
    20
    21 				;===============================================================
    22
    23 					.macro m_convert_menu_entry_number	;Convert menu_entry_number to menu bank_number and bank_address, parameter 1 is the offset
    24 				
    25 				;	Capital letters are variable E=entry, B=bank, A=address, lower case letters are bit number "f..0".
    26 				;	00000000000000Ef EeEdEcEbEaE9E8E7 000000E6E5E4E3E2 E1E0000000000000
    27 				;	BfBeBdBcBbBaB9B8 B7B6B5B4B3B2B1B0 AfAeAdAcAbAaA9A8 A7A6A5A4A3A2A1A0
    28 				
    29 					lda menu_entry_number
    30 					asl
    31 					lda menu_entry_number+1
    32 					rol
    33 					sta bank_number
    34 					lda #0
    35 					sta bank_address
    36 					rol
    37 					sta bank_number+1
    38 				
    39 					adw bank_number menu_mcb.menu_entries_start_bank_number 
    40 				
    41 					lda menu_entry_number
    42 					and #$7f
    43 					lsr
    44 					ror bank_address
    45 					lsr
    46 					ror bank_address
    47 					clc
    48 					adc #>module_a000
    49 					sta bank_address+1
    50 				
    51 					adw bank_address #:1
    52 					.endm
    53
    54 					.macro m_convert_found_entry_index	;:1 found_entry_index, :2 found_entry_pointer
    55 					mwa :1 :2
    56 					asl :2
    57 					rol :2+1
    58 					lda :2+1
    59 					adc #>found_entries
    60 					sta :2+1
    61 					.endm
    62 				;===============================================================
    63
    64 0800				.proc main			;This is the first part executed in RAM
    65
    66 0800 4C 1A 08			jmp skip_signature
    67
    68 0803 54 68 65 21 43 61 + 	.byte 'The!Cart Extended Menu',0
    69
    70 081A			skip_signature
    71
    72 081A AD 1F D0			lda consol			;Holding down SELECT disables the cartrigde and performs coldstart
    73 081D 29 02			and #2
    74 081F D0 03 4C D1 1C		jeq starter.cold_start
    75
    76 0824 AD 1F D0			lda consol			;Holding down OPTION starts simple menu
    77 0827 29 04			and #4
    78 0829 D0 03 4C F1 1C		jeq starter.start_simple_menu	;This only works for "The!Cart", not yet for Atarimax
    79
    80 082E 20 3A 08			jsr init			;Init extended menu scree
    81
    82 0831 20 F8 0B			jsr search.loop
    83 0834 20 A0 08			jsr exit
    84 0837 4C C3 1C			jmp starter
    85
    86 					.endp				;End of main
    87
    88 				;===============================================================
    89
    90 083A				.proc init
    91 083A A9 00			lda #0				;Deactivate screen at first
    92 083C 8D 2F 02			sta sdmctl
    93 083F 8D 00 D4			sta dmactl
    94
    95 0842 78				sei				;Disable VBI stage 2
    96 0843 A9 01 85 E2			mva #1 result.semaphore		;Lock VBI semaphore
    97
    98 0847 AD 22 02 8D EF 08 + 	mwa vvblki exit.saved_vvblki
    99 0853 AD 24 02 8D F1 08 + 	mwa vvblkd exit.saved_vvblkd
   100
   101 085F A9 06			lda #6				;Setup immediate VBI
   102 0861 A2 08			ldx #>nmi.vbi.immediate
   103 0863 A0 F3			ldy #<nmi.vbi.immediate
   104 0865 20 5C E4			jsr setvbv
   105
   106 0868 A9 07			lda #7				;Setup deferred VBI
   107 086A A2 09			ldx #>nmi.vbi.deferred
   108 086C A0 1D			ldy #<nmi.vbi.deferred
   109 086E 20 5C E4			jsr setvbv
   110
   111 0871 20 74 09			jsr genres.init
   112 0874 20 42 10			jsr input.init
   113 0877 20 5C 0E			jsr cursor.init
   114
   115 087A 20 03 12			jsr visualization.screen.init
   116 087D 20 91 19			jsr visualization.menu.init
   117 0880 20 9A 19			jsr visualization.menu.print_menu_title
   118 0883 20 6B 1A			jsr visualization.menu.print_selected_genre
   119 0886 20 07 1A			jsr visualization.menu.print_menu_entries_count
   120 0889 20 FB 19			jsr visualization.menu.print_welcome
   121
   122 088C 20 BC 09			jsr result.clear_result_screen
   123 088F 20 00 0A			jsr result.clear_result_lines
   124
   125 0892 20 BE 12			jsr visualization.screen.activate
   126
   127 0895 A9 01 8D 17 10		mva #1 input.input_changed	;Trigger search
   128
   129 089A A9 00 85 E2			mva #0 result.semaphore		;Unlock VBI semaphore
   130 089E 58				cli				;Enable VBI stage 2
   131 089F 60				rts
   132
   133 					.endp				;End of init
   134
   135 				;===============================================================
   136
   137 08A0				.proc exit
   138 08A0				.var saved_vvblki .word
   139 08A0				.var saved_vvblkd .word
   140
   141 08A0 A9 01 85 E2			mva #1 result.semaphore
   142
   143 08A4 20 C4 12			jsr visualization.screen.exit
   144
   145 08A7 78				sei			;Prevent VBI stage 2 before disabling The!Cart
   146 08A8 A9 00 8D A2 D5		mva #0 the_cart.primary_bank_enable
   147 08AD AD 13 D0 8D FA 03		mva trig3 gintlk	;Make sure cartridge status is up to date
   148 08B3 58				cli			;Enable VBI state 2 again
   149
   150 08B4 A9 07			lda #7			;Restore old deferred VBI
   151 08B6 AE F2 08			ldx saved_vvblkd+1
   152 08B9 AC F1 08			ldy saved_vvblkd
   153 08BC 20 5C E4			jsr setvbv
   154
   155 08BF A9 06			lda #6			;Restore old immeditate VBI
   156 08C1 AE F0 08			ldx saved_vvblki+1
   157 08C4 AC EF 08			ldy saved_vvblki
   158 08C7 20 5C E4			jsr setvbv
   159
   160 08CA A2 00			ldx #$00		;Open E: via CIO to ensure ICBOs are setup correctly
   161 08CC A9 0C 9D 42 03		mva #cio_command.close iccom,x
   162 08D1 20 56 E4			jsr ciov
   163
   164 08D4 A9 03 9D 42 03		mva #cio_command.open iccom,x
   165 08D9 A9 0C 9D 4A 03		mva #12 icax1,x
   166 08DE A9 EC 9D 44 03 A9 + 	mwa #editor icbal,x
   167 08E8 20 56 E4			jsr ciov
   168 08EB 60				rts
   169
   170 08EC				.local editor
   171 08EC 45 3A 9B			.byte 'E:',$9b
   172 					.endl
   173
   174 = 08EF 00 00		SAVED_VVBLKI
   174 = 08F1 00 00		SAVED_VVBLKD
   174 					.endp			;End of exit
   175
   176
   177 				;===============================================================
   178
   179 08F3				.proc nmi
   180
   181 08F3				.proc vbi
   182
   183 08F3				.proc immediate
   184 08F3 AD 13 D0 8D FA 03		mva trig3 gintlk	;Prevent lockup when module is switched on/off. 
   185 08F9 AD 2F 02 8D 00 D4		mva sdmctl dmactl	;Ensure DMA control is ready to fetch actual DL
   186 08FF AE F4 02 8E 09 D4 + 	mwx chbas  chbase	;Ensure font is ready, too
   187 090B 29 20			and #$20		;Check if DL fetching is active
   188 090D F0 05			beq no_dli
   189 090F A9 C0 8D 0E D4		mva #$c0 nmien		;Enable DLIs only when DL fetching is active	
   190 0914			no_dli
   191 0914 20 ED 12			jsr visualization.screen.nmi.vbi
   192 0917 20 55 0D			jsr search.increment_frame_counter
   193
   194 091A 4C 5F E4			jmp sysvbv 		;Perform rest of standard VBI
   195 					.endp			;End of immediate
   196
   197 				;===============================================================
   198 					
   199 091D				.proc deferred		;Perform actual menu handling 
   200
   201 091D 58				cli			;Don't block shadow register updates
   202
   203 091E 20 6B 1C			jsr visualization.result_status.print_found_entry_index
   204
   205 0921 20 5A 10			jsr input.handle_keys	;Handle keyboard input for search terms
   206
   207 0924 AD 15 10			lda input.input_help_mode
   208 0927 D0 41			bne semaphore_locked	;Do nothing in help mode
   209 0929 A5 E2			lda result.semaphore
   210 092B D0 3D			bne semaphore_locked	;Do nothing if semaphore is locked
   211
   212 092D A9 01 85 E2			mva #1 result.semaphore
   213 					
   214 0931 20 F5 07			jsr menu_core.get_bank
   215 0934 8E 60 09			stx old_bank_lo
   216 0937 8C 62 09			sty old_bank_hi
   217
   218 093A				.proc logic
   219 093A AD 17 10			lda input.input_changed	;Any pending input?
   220 093D F0 0B			beq input_unchanged
   221 093F A9 00 8D 17 10		mva #0 input.input_changed
   222 0944 20 00 0A			jsr result.clear_result_lines
   223 0947 20 15 0A			jsr result.start_search_for_input
   224 094A			input_unchanged
   225
   226 094A 20 76 0E			jsr cursor.move_cursor	;Handle joystick and cursor keys
   227
   228 094D AD 72 0D			lda controls.stick
   229 0950 29 10			and #joystick.fire
   230 0952 D0 05			bne no_fire_or_return
   231 0954 A9 02 8D 65 0D		mva #search.status.start_selected_entry search.search_status
   232 0959			no_fire_or_return
   233
   234 0959 20 45 0A			jsr result.update_top_line	;Compute visible scroll area
   235 095C 20 74 0A			jsr result.update_result_lines
   236
   237 					.endp
   238
   239 = 0960			old_bank_lo = *+1
   240 095F A2 00			ldx #$00
   241 = 0962			old_bank_hi = *+1
   242 0961 A0 00			ldy #$00
   243 0963 20 D6 07			jsr menu_core.set_bank
   244
   245 0966 A9 00 85 E2			mva #0 result.semaphore
   246 096A			semaphore_locked
   247
   248 096A 4C 62 E4			jmp xitvbv
   249 					.endp			;End of deferred
   250
   251 				;===============================================================
   252
   253 096D				.proc wait_next_vbi
   254 096D A5 14			lda $14
   255 096F C5 14		loop	cmp $14
   256 0971 F0 FC			beq loop
   257 0973 60				rts
   258 					.endp
   259
   260 				;===============================================================
   261
   262 					.endp		;End of vbi
   263
   264 					.endp		;End of nmi
   265
   266 				;===============================================================
   267
   268 0974				.proc genres
   269 0974				.proc init
   270
   271 0974 A6 A6			ldx menu_mcb.menu_genres_start_bank_number
   272 0976 A4 A7			ldy menu_mcb.menu_genres_start_bank_number+1
   273 0978 20 D6 07			jsr menu_core.set_bank
   274
   275 097B A5 A4			lda menu_mcb.menu_genres_count 
   276 097D 0A				asl
   277 097E 85 86			sta x1
   278
   279 0980 A2 00			ldx #0
   280 0982			genres_loop
   281 0982 18 BD 00 A0 69 00 + 	adw module_a000,x #module_a000 p1
   282 0991 18 BD 00 A0 69 00 + 	adw module_a000,x #genres_list p2
   283 09A0 A5 82 9D 00 34 A5 + 	mwa p2 genres_list,x
   284
   285 09AA A0 00			ldy #0
   286 09AC			character_loop
   287 09AC B1 80			lda (p1),y
   288 09AE 91 82			sta (p2),y
   289 09B0 C8				iny
   290 09B1 C9 00			cmp #0
   291 09B3 D0 F7			bne character_loop
   292 09B5 E8				inx
   293 09B6 E8				inx
   294 09B7 E4 86			cpx x1
   295 09B9 D0 C7			bne genres_loop
   296 09BB 60				rts
   297 					.endp
   298 					.endp
   299
   300 				;===============================================================
   301
   302 09BC				.proc result
   303
   304 09BC				.enum status
   305 = 0000				searching		= $00
   306 = 0001				not_searching		= $01
   307 = 0081				finished_complete	= $81
   308 = 0082				finished_incomplete	= $82
   309 = 0083				finished_user_break	= $83
   310 					.ende
   311
   312 = 00E2			semaphore		= vbi_zp	;Byte
   313 = 00E3			result_status		= vbi_zp+1	;Byte, synchronized via vbi.semaphore
   314 = 00E4			found_entry_index	= vbi_zp+2	;Word, synchronized via vbi.semaphore
   315 = 00E6			found_entry_pointer	= vbi_zp+4	;Word, synchronized via vbi.semaphore
   316 = 00E8			top_entry_index		= vbi_zp+6	;Word
   317 = 00EA			top_entry_pointer	= vbi_zp+8	;Word
   318 = 00EC			menu_entry_number	= vbi_zp+10	;Word
   319 = 00EE			bank_number		= vbi_zp+12	;Word
   320 = 00F0			bank_address		= vbi_zp+14	;Word
   321 = 00F2			screen_address		= vbi_zp+16	;Word
   322
   323 				;===============================================================
   324
   325 09BC				.proc clear_result_screen		;Clear result screen
   326 09BC A9 20			lda #' '
   327 09BE A2 27			ldx #screen_width-1
   328 09C0			loop
   329 					.rept result_lines
   330 					STA RESULT_SM+#*SCREEN_WIDTH,X
   331 					.ENDR
   331 					.endr
Source: REPT
   330 09C0 9D 50 30			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09C3 9D 78 30			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09C6 9D A0 30			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09C9 9D C8 30			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09CC 9D F0 30			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09CF 9D 18 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09D2 9D 40 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09D5 9D 68 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09D8 9D 90 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09DB 9D B8 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09DE 9D E0 31			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09E1 9D 08 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09E4 9D 30 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09E7 9D 58 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09EA 9D 80 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09ED 9D A8 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09F0 9D D0 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09F3 9D F8 32			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09F6 9D 20 33			STA RESULT_SM+#*SCREEN_WIDTH,X
   330 09F9 9D 48 33			STA RESULT_SM+#*SCREEN_WIDTH,X
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   332
   333 09FC CA				dex
   334 09FD 10 C1			bpl loop
   335 09FF 60				rts
   336 					.endp
   337
   338 				;===============================================================
   339
   340 0A00				.proc clear_result_lines	;Clear result list
   341 0A00 A2 13			ldx #result_lines-1
   342 0A02			clear_result_lines
   343 0A02 A9 FF			lda #$ff
   344 0A04 9D A8 0B			sta displayed_entries.lo,x
   345 0A07 9D BC 0B			sta displayed_entries.hi,x
   346 0A0A 20 44 1A			jsr visualization.menu.clear_entry_colors
   347 0A0D CA				dex
   348 0A0E 10 F2			bpl clear_result_lines
   349
   350 0A10 A9 01 85 E3			mva #status.not_searching result_status
   351 0A14 60				rts
   352 					.endp
   353
   354 				;===============================================================
   355 0A15				.proc start_search_for_input	;Mark result as incomplete and start searching first entry with current input
   356
   357 0A15 A9 00 85 E4 85 E5		mwa #0 found_entry_index	;Start with first entry
   358 0A1B A9 00 85 E6 A9 3C + 	mwa #found_entries found_entry_pointer
   359 0A23 A9 00 85 E3			mva #status.searching result.result_status
   360 0A27 20 A3 1B			jsr visualization.result_status.print_searching
   361
   362 0A2A 20 65 0E			jsr cursor.clear_cursor
   363 0A2D A9 03 8D 65 0D		mva #search.status.restart search.search_status
   364
   365 0A32				.proc copy_input_buffer		;Copy input buffer to search
   366 0A32 AE 18 10			ldx input.input_length		;Copy length
   367 0A35 8E 66 0D			stx search.input_length
   368 0A38 CA			loop	dex				;Copy characters
   369 0A39 30 09			bmi done
   370 0A3B BD 1A 10 9D D0 0B		mva input.input_buffer,x search.input_buffer,x
   371 0A41 4C 38 0A			jmp loop
   372 0A44			done
   373 					.endp
   374 0A44 60				rts
   375
   376 					.endp
   377
   378 				;===============================================================
   379
   380 0A45				.proc update_top_line
   381 = 000A				middle_line = result_lines/2	;Middle line of the screen
   382
   383 0A45 A5 E4			lda found_entry_index
   384 0A47 05 E5			ora found_entry_index+1
   385 0A49 D0 04			bne found_something
   386 0A4B A9 FF			lda #$ff 			;Nothing found, clear cursor line
   387 0A4D D0 21			bne set_cursor_line
   388
   389 0A4F			found_something
   390 0A4F 38 AD 4A 0E E9 0A + 	sbw cursor.cursor_line #middle_line top_entry_index
   391 0A5E B0 0E			bcs more
   392
   393 0A60 18				clc
   394 0A61 A5 E8			lda top_entry_index
   395 0A63 69 0A			adc #middle_line
   396 0A65 A2 00 86 E8 86 E9		mwx #0 top_entry_index
   397 0A6B 4C 70 0A			jmp set_cursor_line
   398
   399 0A6E A9 0A		more	lda #middle_line
   400
   401 0A70			set_cursor_line
   402 0A70 20 54 1A			jsr visualization.menu.set_cursor_line	;IN: <A>=cursor line, $ff for cursor off
   403 0A73 60				rts
   404 					.endp
   405
   406 				;===============================================================
   407
   408 0A74				.proc update_result_lines	;Update the result list
   409 0A74				.var line_number .byte		;Line number of the currently processed line
   410 0A74				.var entry_counter .word	;Number of visible entries that can be displayed from the result
   411
   412 0A74				m_convert_found_entry_index top_entry_index top_entry_pointer
Macro: EXTENDED_MENU.M_CONVERT_FOUND_ENTRY_INDEX [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm]
     1 0A74 A5 E8 85 EA A5 E9 + 	mwa TOP_ENTRY_INDEX TOP_ENTRY_POINTER
     2 0A7C 06 EA			asl TOP_ENTRY_POINTER
     3 0A7E 26 EB			rol TOP_ENTRY_POINTER+1
     4 0A80 A5 EB			lda TOP_ENTRY_POINTER+1
     5 0A82 69 3C			adc #>found_entries
     6 0A84 85 EB			sta TOP_ENTRY_POINTER+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   413
   414 0A86 A5 E4 85 02 A5 E5 + 	mwa found_entry_index $0002
   415 0A8E A5 E8 85 04 A5 E9 + 	mwa top_entry_index $0004
   416 					
   417 0A96 38 A5 E4 E5 E8 8D + 	sbw found_entry_index top_entry_index entry_counter
   418 0AA5 B0 08			bcs no_underflow
   419 0AA7 A9 00 8D 7E 0B 8D + 	mwa #0 entry_counter		;Make negative value to 0
   420 0AAF			no_underflow
   421 0AAF AD 7F 0B			lda entry_counter+1
   422 0AB2 F0 05			beq no_high_byte
   423 0AB4 A9 FF 8D 7E 0B		mva #$ff entry_counter		;Limit entry_counter to byte value
   424 0AB9			no_high_byte
   425
   426 0AB9 AD 7E 0B 85 06 AD + 	mwa entry_counter $0006
   427 					
   428 0AC3 A2 00			ldx #0
   429 0AC5			display_entry_loop
   430 0AC5 EC 7E 0B			cpx entry_counter		;Any more entries to display? (only low byte is relevant)
   431 0AC8 B0 22			bcs clear_entry			;No more entries found, clear remaining entries on screen
   432
   433 0ACA A0 00			ldy #0				;Check if number from the result and currently displayed number are different
   434 0ACC B1 EA			lda (top_entry_pointer),y
   435 0ACE DD A8 0B			cmp displayed_entries.lo,x
   436 0AD1 D0 2E			bne display_entry		;Yes, display entry
   437 0AD3 C8				iny
   438 0AD4 B1 EA			lda (top_entry_pointer),y
   439 0AD6 DD BC 0B			cmp displayed_entries.hi,x
   440 0AD9 D0 26			bne display_entry		;Yes display entry
   441
   442 0ADB			display_entry_next
   443 0ADB 18 A5 EA 69 02 85 + 	adw top_entry_pointer #2	;Next entry in the result
   444 0AE6 E8				inx
   445 0AE7 E0 14			cpx #result_lines
   446 0AE9 D0 DA			bne display_entry_loop
   447 0AEB 60				rts
   448
   449 				;===============================================================
   450
   451 0AEC				.proc clear_entry
   452 0AEC BD BC 0B			lda displayed_entries.hi,x	;Already cleared?
   453 0AEF C9 FF			cmp #$ff
   454 0AF1 F0 E8			beq display_entry_next
   455
   456 0AF3 A9 FF			lda #$ff			;Mark entry as cleared
   457 0AF5 9D A8 0B			sta displayed_entries.lo,x
   458 0AF8 9D BC 0B			sta displayed_entries.hi,x
   459
   460 0AFB 20 44 1A			jsr visualization.menu.clear_entry_colors;IN: <X>=line
   461 0AFE 4C DB 0A			jmp display_entry_next
   462 					.endp
   463
   464 				;===============================================================
   465
   466 0B01				.proc display_entry
   467 0B01 8E 7D 0B			stx line_number			;Remember current line
   468
   469 0B04 A0 00			ldy #0				;Copy next found entry number to displayed entries and menu_entry_number
   470 0B06 B1 EA			lda (top_entry_pointer),y
   471 0B08 9D A8 0B			sta displayed_entries.lo,x
   472 0B0B 85 EC			sta menu_entry_number
   473 0B0D C8				iny
   474 0B0E B1 EA			lda (top_entry_pointer),y
   475 0B10 9D BC 0B			sta displayed_entries.hi,x
   476 0B13 85 ED			sta menu_entry_number+1
   477
   478 0B15				m_convert_menu_entry_number menu_entry.title
Macro: EXTENDED_MENU.M_CONVERT_MENU_ENTRY_NUMBER [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm]
     6 0B15 A5 EC			lda menu_entry_number
     7 0B17 0A				asl
     8 0B18 A5 ED			lda menu_entry_number+1
     9 0B1A 2A				rol
    10 0B1B 85 EE			sta bank_number
    11 0B1D A9 00			lda #0
    12 0B1F 85 F0			sta bank_address
    13 0B21 2A				rol
    14 0B22 85 EF			sta bank_number+1
    16 0B24 18 A5 EE 65 AA 85 + 	adw bank_number menu_mcb.menu_entries_start_bank_number 
    18 0B31 A5 EC			lda menu_entry_number
    19 0B33 29 7F			and #$7f
    20 0B35 4A				lsr
    21 0B36 66 F0			ror bank_address
    22 0B38 4A				lsr
    23 0B39 66 F0			ror bank_address
    24 0B3B 18				clc
    25 0B3C 69 A0			adc #>module_a000
    26 0B3E 85 F1			sta bank_address+1
    28 0B40 18 A5 F0 69 0E 85 + 	adw bank_address #MENU_ENTRY.TITLE
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   479
   480 0B4B BD 80 0B			lda screen_lines.lo,x
   481 0B4E 85 F2			sta screen_address
   482 0B50 BD 94 0B			lda screen_lines.hi,x
   483 0B53 85 F3			sta screen_address+1
   484
   485 0B55 A6 EE			ldx bank_number			;This changes <X>
   486 0B57 A4 EF			ldy bank_number+1
   487 0B59 20 D6 07			jsr menu_core.set_bank
   488
   489 0B5C A0 27			ldy #screen_width-1		;Copy entry title
   490 0B5E			loop
   491 					.rept 4
   492 					LDA (BANK_ADDRESS),Y
   493 					STA (SCREEN_ADDRESS),Y
   494 					DEY
   495 					.ENDR
   495 					.endr
Source: REPT
   492 0B5E B1 F0			LDA (BANK_ADDRESS),Y
   492 0B60 91 F2			STA (SCREEN_ADDRESS),Y
   492 0B62 88				DEY
   492 0B63 B1 F0			LDA (BANK_ADDRESS),Y
   492 0B65 91 F2			STA (SCREEN_ADDRESS),Y
   492 0B67 88				DEY
   492 0B68 B1 F0			LDA (BANK_ADDRESS),Y
   492 0B6A 91 F2			STA (SCREEN_ADDRESS),Y
   492 0B6C 88				DEY
   492 0B6D B1 F0			LDA (BANK_ADDRESS),Y
   492 0B6F 91 F2			STA (SCREEN_ADDRESS),Y
   492 0B71 88				DEY
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   496 0B72 10 EA			bpl loop
   497
   498 0B74 AE 7D 0B			ldx line_number			;Set entry colors
   499 0B77 20 32 1A			jsr visualization.menu.set_entry_colors	;IN: <X>=line
   500
   501 0B7A 4C DB 0A			jmp display_entry_next
   502 					.endp
   503
   504 				;===============================================================
   505
   506
   507 = 0B7D 00		LINE_NUMBER
   507 = 0B7E 00 00		ENTRY_COUNTER
   507 					.endp			;End of update_result_lines
   508
   509 				;===============================================================
   510
   511 0B80				.local screen_lines	;Screen line addresses
   512 0B80				.local lo
   513 					.rept result_lines
   514 					.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   515 					.ENDR
   515 					.endr
Source: REPT
   514 0B80 50				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B81 78				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B82 A0				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B83 C8				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B84 F0				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B85 18				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B86 40				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B87 68				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B88 90				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B89 B8				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8A E0				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8B 08				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8C 30				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8D 58				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8E 80				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B8F A8				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B90 D0				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B91 F8				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B92 20				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
   514 0B93 48				.BYTE <[RESULT_SM+#*SCREEN_WIDTH]
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   516 					.endl			;End of lo
   517 0B94				.local hi
   518 					.rept result_lines
   519 					.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   520 					.ENDR
   520 					.endr
Source: REPT
   519 0B94 30				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B95 30				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B96 30				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B97 30				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B98 30				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B99 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9A 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9B 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9C 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9D 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9E 31				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0B9F 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA0 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA1 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA2 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA3 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA4 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA5 32				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA6 33				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
   519 0BA7 33				.BYTE >[RESULT_SM+#*SCREEN_WIDTH]
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   521 					.endl			;End of hi
   522 					.endl
   523
   524 0BA8				.local displayed_entries ;Numbers of visible entries that are already displayed	
   525 0BA8				.local lo
   526 = 0BA8				.ds result_lines
   527 					.endl
   528 0BBC				.local hi
   529 = 0BBC				.ds result_lines
   530 					.endl
   531 					.endl
   532 					
   533 					.endp		;End of result
   534
   535 				;===============================================================
   536
   537 0BD0				.proc search
   538
   539 0BD0				.enum status
   540 = 0000				searching		= $00
   541 = 0001				start_simple_menu 	= $01
   542 = 0002				start_selected_entry	= $02
   543 = 0003				restart			= $03
   544 					.ende
   545
   546 0BD0				.var search_status .byte		;Public, write access
   547 0BD0				.var input_length .byte			;Public, write access
   548 = 0BD0			input_buffer .ds input.input_max_length		;Public, write access
   549 0BF8				.var search_genre_number .byte		;Private, fill when search is started
   550 0BF8				.var search_entry_max_index .word	;Private, maximum number of entries that fit into found_entries
   551 0BF8				.var search_entry_index	.word		;Private, counting up, read access by visualization
   552 0BF8				.var search_entry_counter .word		;Private, counting down, read access by visualization
   553 0BF8				.var search_bank_number	.word		;Private, read access by visualization
   554 0BF8				.var search_frame_counter .word		;Private, see increment_frame_counter, read access by visualization
   555
   556 = 0080				search_pointer = p1			;Private zero page pointer
   557
   558 				;===============================================================
   559
   560 0BF8				.proc loop				;Main search loop
   561
   562 0BF8			search_restart
   563 0BF8 20 6D 09			jsr nmi.vbi.wait_next_vbi		;Wait for VBI processing to complete search_frame_counter handling
   564 0BFB 20 0B 0C			jsr init_search_entries
   565
   566 0BFE			search_loop
   567 0BFE 20 5A 0C			jsr search_next_entry
   568 0C01 AD 65 0D			lda search_status			;Cancelled by user selection?
   569 0C04 F0 F8			beq search_loop
   570 0C06 C9 03			cmp #status.restart
   571 0C08 F0 EE			beq search_restart
   572
   573 0C0A 60				rts
   574
   575 				;===============================================================
   576
   577 0C0B				.proc init_search_entries
   578 0C0B A9 00 8D 65 0D		mva #status.searching search_status	;Start searching	
   579
   580 0C10 AD 4E 0E 8D 67 0D		mva cursor.selected_genre.number search_genre_number
   581
   582 				;	Compute number of entries that will fit into the found_entries
   583 				;	The end of the physical ram is store in memtop.
   584 				;	While ramtop ($6a) and ramsiz ($2e4) are change to $c0 during
   585 				;	startup, the value of memtop ($2e5/$2e6) is unchanged here.
   586 0C16 AD E6 02			lda memtop+1
   587 0C19 38				sec
   588 0C1A E9 3C			sbc #>found_entries
   589 0C1C 4A				lsr
   590 0C1D 8D 69 0D			sta search_entry_max_index+1
   591
   592 0C20 A9 00 8D 6A 0D 8D + 	mwa #0 search_entry_index
   593 0C28 A5 A8 8D 6C 0D A5 + 	mwa menu_mcb.menu_entries_count search_entry_counter
   594 0C32 A5 AA 8D 6E 0D A5 + 	mwa menu_mcb.menu_entries_start_bank_number search_bank_number
   595 0C3C A9 00 85 80 A9 A0 + 	mwa #module_a000 search_pointer
   596 					
   597 0C44 A9 00 8D 70 0D 8D + 	mwa #0 search_frame_counter
   598
   599 0C4C A9 FF 85 11			mva #$ff brkkey
   600
   601 0C50 AE 6E 0D			ldx search_bank_number			;Activate first bank to search in
   602 0C53 AC 6F 0D			ldy search_bank_number+1
   603 0C56 20 D6 07			jsr menu_core.set_bank
   604 0C59 60				rts
   605
   606 					.endp
   607
   608 				;===============================================================
   609
   610 0C5A				.proc search_next_entry
   611
   612 0C5A A5 E3			lda result.result_status		;Dirty read first
   613 0C5C F0 03 4C 50 0D		jne not_searching_or_finished		;Not searching or finished
   614
   615 0C61 A9 01 85 E2			mva #1 result.semaphore			;Synchronized read to make sure
   616 0C65 A5 E3			lda result.result_status		;Check is result is already complete?
   617 0C67 F0 03 4C 50 0D		jne not_searching_or_finished
   618
   619 0C6C AD 65 0D			lda search.search_status		;Check if search shall still be continued?
   620 0C6F C9 00			cmp #status.searching
   621 0C71 F0 03 4C 50 0D		jne not_searching_or_finished
   622
   623 0C76 AD 6C 0D			lda search_entry_counter		;Check if there are any more entries in the menu?
   624 0C79 0D 6D 0D			ora search_entry_counter+1
   625 0C7C D0 0A			bne not_finished_complete		;Mark result as complete?
   626 0C7E A9 81 85 E3			mva #result.status.finished_complete result.result_status
   627 0C82 20 D1 1B			jsr visualization.result_status.print_search_finished_complete
   628 0C85 4C 50 0D			jmp finished				;Done with complete result.
   629
   630 0C88			not_finished_complete
   631 0C88 A5 11			lda brkkey
   632 0C8A D0 0A			bne not_finished_user_break
   633 0C8C A9 83 85 E3			mva #result.status.finished_user_break result.result_status
   634 0C90 20 3D 1C			jsr visualization.result_status.print_search_finished_user_break
   635 0C93 4C 50 0D			jmp finished				;Done with incomplete result.
   636
   637 0C96			not_finished_user_break
   638 0C96 A0 36			ldy #menu_entry.genre_number
   639 0C98 AD 67 0D			lda search_genre_number
   640 0C9B F0 04			beq not_specific_genre			;If the search genre is not specific, continue with comparing the title
   641 0C9D D1 80			cmp (search_pointer),y			;If the search genre is specific...
   642 0C9F D0 74			bne entry_not_matching			;... but it's different from the entry genre, then it's no match
   643
   644 0CA1			not_specific_genre
   645 0CA1 AE 66 0D			ldx input_length			;Empty string matches everything
   646 0CA4 F0 37			beq matching_entry_found
   647
   648 				;	ldx #0					;Find first substring
   649 				;	.proc find_substring_start
   650 				;loop	lda input_buffer,x
   651 				;	cmp #' '
   652 				;	bne found
   653 				;	inx
   654 				;	cpx input_length
   655 				;	bne loop
   656 				;	beq substring_not_matching
   657 				;found
   658 				;	.endp
   659 				;	stx substring_start
   660 				;find_substring_loop
   661 				;	lda input_buffer,x
   662 				;	cmp #' '
   663 				;	beq substring_end_found
   664 				;	inx
   665 				;	cpx input_length
   666 				;	bne find_substring_loop
   667 				;substring_end_found
   668
   669 0CA6 8E D0 0C			stx search_substring.compare_input_length ;Self-modifying code to save cycles
   670
   671 0CA9				.proc search_substring
   672 = 0086				position = x1				;ZP variables
   673
   674 0CA9 A9 0E 85 86			mva #menu_entry.title position		;Compare entry with input buffer
   675 0CAD A0 0D			ldy #menu_entry.title_length		;end_position = title position+<title_length>
   676 0CAF 71 80			adc (search_pointer),y
   677 0CB1 8D B9 0C			sta compare_end_position		;Self-modifying code to save cycles
   678
   679 0CB4			compare_next_position
   680 0CB4 A2 00			ldx #0
   681 0CB6 A4 86			ldy position
   682
   683 0CB8			compare_next_char
   684
   685 = 0CB9			compare_end_position = *+1
   686 0CB8 C0 FF			cpy #$ff
   687 0CBA B0 59			bcs entry_not_matching
   688 0CBC B1 80			lda (search_pointer),y
   689 0CBE C9 61			cmp #'a'
   690 0CC0 90 06			bcc no_lower_case
   691 0CC2 C9 7B			cmp #'z'+1
   692 0CC4 B0 02			bcs no_lower_case
   693 0CC6 E9 1F			sbc #$20-1
   694 0CC8			no_lower_case
   695 0CC8 DD D0 0B			cmp input_buffer,x
   696 0CCB D0 08			bne no_char_match_found			;Restart compare for substring at next position
   697 0CCD C8				iny
   698 0CCE E8				inx
   699 = 0CD0			compare_input_length = *+1
   700 0CCF E0 FF			cpx #$ff
   701 0CD1 90 E5			bcc compare_next_char
   702 0CD3 B0 08			bcs matching_subtring_found		;All characters compared
   703
   704 0CD5			no_char_match_found
   705 0CD5 E6 86			inc position
   706 0CD7 4C B4 0C			jmp compare_next_position
   707
   708 0CDA			substring_not_matching
   709 0CDA 4C 15 0D			jmp entry_not_matching
   710
   711 0CDD			matching_subtring_found
   712 					.endp					;End of search_substring
   713
   714 0CDD				.proc matching_entry_found
   715 0CDD A5 E5			lda result.found_entry_index+1 		;Check if there is space for more found entries in the list
   716 0CDF CD 69 0D			cmp search_entry_max_index+1
   717 0CE2 90 0A			bcc not_finished_incomplete		;Mark result as incomplete?
   718 0CE4 A9 82 85 E3			mva #result.status.finished_incomplete result.result_status
   719 0CE8 20 07 1C			jsr visualization.result_status.print_search_finished_incomplete
   720 0CEB 4C 50 0D			jmp finished				;Done with incomplete result.
   721 0CEE			not_finished_incomplete
   722
   723 0CEE A0 00			ldy #0					;Enter current search_entry_index in the found_entries
   724 0CF0 AD 6A 0D			lda search_entry_index
   725 0CF3 91 E6			sta (result.found_entry_pointer),y
   726 0CF5 C8				iny
   727 0CF6 AD 6B 0D			lda search_entry_index+1
   728 0CF9 91 E6			sta (result.found_entry_pointer),y
   729
   730 0CFB A5 E4			lda result.found_entry_index		;If the first entry is found, the cursor becomes releveant
   731 0CFD 05 E5			ora result.found_entry_index+1		;and the data for the entry must be selected
   732 0CFF D0 03			bne not_first_rentry
   733 0D01 20 5E 0F			jsr cursor.get_selected_entry.some_entries_found	;Cursor line is zero at this point
   734 0D04			not_first_rentry
   735
   736 0D04 E6 E4 D0 02 E6 E5		inw result.found_entry_index		;Step to next free found_entry index
   737 0D0A 18 A5 E6 69 02 85 + 	adw result.found_entry_pointer #2	;Step to next free found_entry address
   738 					.endp					;End of match_found
   739
   740 0D15			entry_not_matching
   741
   742 0D15			next_entry
   743 0D15 EE 6A 0D D0 03 EE + 	inw search_entry_index			;Increament entries index
   744 0D1D AD 6C 0D D0 03 CE + 	dew search_entry_counter		;Decrement remaining entries counter
   745
   746 0D28 18				clc					;Increment pointer and bank number
   747 0D29 A5 80			lda search_pointer
   748 0D2B 69 40			adc #menu_entry_size
   749 0D2D 85 80			sta search_pointer
   750 0D2F A5 81			lda search_pointer+1
   751 0D31 69 00			adc #0
   752 0D33 85 81			sta search_pointer+1
   753 0D35 C9 C0			cmp #>[module_a000+bank_size]
   754 0D37 90 17			bcc not_next_bank
   755 0D39 A9 A0			lda #>module_a000
   756 0D3B 85 81			sta search_pointer+1
   757 0D3D EE 6E 0D D0 03 EE + 	inw search_bank_number
   758 0D45 AE 6E 0D			ldx search_bank_number			;Activate bank of the entry to search in
   759 0D48 AC 6F 0D			ldy search_bank_number+1
   760 0D4B 20 D6 07			jsr menu_core.set_bank
   761 0D4E			search_bank_number_not_high
   762 0D4E A5 11			lda brkkey
   763 					
   764 0D50			not_next_bank
   765
   766 0D50			finished
   767
   768 0D50			not_searching_or_finished
   769 0D50 A9 00 85 E2			mva #0 result.semaphore
   770
   771 0D54 60				rts
   772 					.endp			;End of next
   773
   774 					.endp			;End of loop
   775
   776 				;===============================================================
   777
   778 0D55				.proc increment_frame_counter
   779 0D55 AD 65 0D			lda search_status		;Check if search shall still be continued?
   780 0D58 C9 00			cmp #status.searching
   781 0D5A D0 08			bne not_searching
   782 0D5C EE 70 0D D0 03 EE + 	inw search_frame_counter
   783 0D64			not_searching
   784 0D64 60				rts
   785 					.endp
   786
   787 				;===============================================================
   788
   789 = 0D65 00		SEARCH_STATUS
   789 = 0D66 00		INPUT_LENGTH
   789 = 0D67 00		SEARCH_GENRE_NUMBER
   789 = 0D68 00 00		SEARCH_ENTRY_MAX_INDEX
   789 = 0D6A 00 00		SEARCH_ENTRY_INDEX
   789 = 0D6C 00 00		SEARCH_ENTRY_COUNTER
   789 = 0D6E 00 00		SEARCH_BANK_NUMBER
   789 = 0D70 00 00		SEARCH_FRAME_COUNTER
   789 					.endp				;End of search
   790
   791 				;===============================================================
   792
   793 0D72				icl "TheMenu-Controls.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Controls.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 0D72				.enum joystick
     7 = 0001			down	= 1
     8 = 0002			up	= 2
     9 = 0004			left	= 4
    10 = 0008			right	= 8
    11 = 0010			fire	= 16
    12 = 001F			any	= 31
    13 					.ende
    14
    15 0D72				.proc controls		;OUT: <A>=joystick, bits with 0 are active
    16
    17 				;===============================================================
    18
    19 0D72 00			stick		   .byte 0	;Public
    20 0D73 00 00		stick_step	   .word 0	;Public, use high byte as step
    21 0D75 00			stick_old	   .byte 0	;Private
    22 0D76 00			start_delay_cnt	   .byte 0	;Private
    23 0D77 00			repeat_delay_new   .byte 0	;Private
    24 0D78 00			repeat_delay_cnt   .byte 0	;Private
    25
    26 0D79				.local bits
    27 0D79 04			left	.byte joystick.left
    28 0D7A 08			right	.byte joystick.right
    29 0D7B 10			fire	.byte joystick.fire
    30 					.endl
    31
    32 				;===============================================================
    33
    34 0D7C				.proc init
    35 0D7C A9 1F			lda #joystick.any
    36 0D7E 8D 72 0D			sta stick
    37 0D81 8D 75 0D			sta stick_old
    38 0D84 60				rts
    39 					.endp
    40
    41 				;===============================================================
    42
    43 0D85				.proc read
    44 = 000A				start_delay = 10
    45 = 0008				repeat_delay = 8
    46
    47 0D85 AD 78 02			lda stick0
    48 0D88 29 0F			and #joystick.left|joystick.right|joystick.up|joystick.down
    49 0D8A AE 10 D0			ldx trig0
    50 0D8D F0 02			seq
    51 0D8F 09 10			ora #joystick.fire
    52 0D91 8D 72 0D			sta stick
    53
    54 0D94 20 09 0E			jsr map_keys
    55
    56 0D97 AD 72 0D			lda stick
    57 0D9A CD 75 0D			cmp stick_old
    58 0D9D F0 17			beq is_same
    59 0D9F A9 0A 8D 76 0D		mva #start_delay start_delay_cnt
    60 0DA4 A9 08 8D 77 0D		mva #repeat_delay repeat_delay_new
    61 0DA9 A9 00 8D 73 0D A9 + 	mwa #$100 stick_step
    62 0DB3 4C F7 0D			jmp return_with_key
    63
    64 0DB6			is_same	
    65 0DB6 C9 1F			cmp #joystick.any
    66 0DB8 F0 49			beq return_without_key
    67 0DBA AD 76 0D			lda start_delay_cnt
    68 0DBD F0 06			beq no_more_start_delay
    69 0DBF CE 76 0D			dec start_delay_cnt
    70 0DC2 4C 03 0E			jmp return_without_key
    71
    72 0DC5			no_more_start_delay
    73 0DC5 AD 78 0D			lda repeat_delay_cnt
    74 0DC8 F0 06			beq no_more_repeat_delay
    75 0DCA CE 78 0D			dec repeat_delay_cnt
    76 0DCD 4C 03 0E			jmp return_without_key
    77
    78 0DD0			no_more_repeat_delay
    79 0DD0 AD 77 0D			lda repeat_delay_new
    80 0DD3 4A				lsr
    81 0DD4 8D 78 0D			sta repeat_delay_cnt
    82 0DD7 AD 77 0D			lda repeat_delay_new
    83 0DDA F0 06			beq repeat_delay_new_zero
    84 0DDC CE 77 0D			dec repeat_delay_new
    85 0DDF 4C F7 0D			jmp return_with_key
    86
    87 0DE2			repeat_delay_new_zero
    88 0DE2 AD 74 0D			lda stick_step+1
    89 0DE5 C9 FF			cmp #$ff
    90 0DE7 F0 0E			beq stick_step_is_max
    91 0DE9 18 AD 73 0D 69 05 + 	adw stick_step #5
    92 0DF7			stick_step_is_max
    93
    94 0DF7			return_with_key
    95 0DF7 A9 07 8D 1F D0		mva #7 consol
    96 0DFC AD 72 0D			lda stick
    97 0DFF 8D 75 0D			sta stick_old
    98 0E02 60				rts
    99
   100 0E03			return_without_key
   101 0E03 A9 1F			lda #joystick.any
   102 0E05 8D 72 0D			sta stick
   103 0E08 60				rts
   104
   105 				;===============================================================
   106
   107 0E09				.proc map_keys		;Map keyboard to joystick
   108 0E09 AD 0F D2			lda skstat
   109 0E0C 29 04			and #4
   110 0E0E D0 39			bne no_key
   111
   112 0E10 AD 09 D2			lda kbcode
   113 0E13 29 3F			and #63
   114 0E15 AA				tax
   115 0E16 AD 72 0D			lda stick
   116
   117 0E19 E0 0C			cpx #$0c		;Map "RETURN" to "FIRE" 
   118 0E1B D0 05			bne no_return
   119 0E1D 29 EF			and #~joystick.fire
   120 0E1F 4C 46 0E			jmp set_key
   121 0E22			no_return
   122 0E22 E0 06			cpx #$06		;Map "CURSOR LEFT" to "LEFT"
   123 0E24 D0 05			bne no_left
   124 0E26 29 FB			and #~joystick.left
   125 0E28 4C 46 0E			jmp set_key
   126 0E2B			no_left
   127 0E2B E0 07			cpx #$07		;Map "CURSOR RIGHT" to "ROGHT"
   128 0E2D D0 05			bne no_right
   129 0E2F			is_right
   130 0E2F 29 F7			and #~joystick.right
   131 0E31 4C 46 0E			jmp set_key
   132 0E34			no_right
   133 0E34 E0 0F			cpx #$0f		;Map "CURSOR UP" to "UP"
   134 0E36 D0 05			bne no_cursor_up
   135 0E38 29 FD			and #~joystick.up
   136 0E3A 4C 46 0E			jmp set_key
   137 0E3D			no_cursor_up
   138 0E3D E0 0E			cpx #$0e		;Map "CURSOR DOWN" to "DOWN"
   139 0E3F D0 05			bne no_cursor_down
   140 0E41 29 FE			and #~joystick.down
   141 0E43 4C 46 0E			jmp set_key
   142 0E46			no_cursor_down
   143
   144 0E46 8D 72 0D		set_key	sta stick
   145 0E49 60			no_key	rts
   146 					.endp			;End of map_keys
   147 					.endp			;End of read
   148
   149 					.endp			;End of controls
   794
   795 0E4A				icl "TheMenu-Cursor.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 				;===============================================================
     7
     8 0E4A				.proc cursor
     9
    10 0E4A 00 00		cursor_line 	 .word		;Public
    11 0E4C 00 00		last_cursor_line .word		;Private
    12
    13 0E4E				.local selected_genre
    14 0E4E 00			number			.byte	;Public
    15 					.endl
    16
    17 0E4F				.local selected_entry	;Public
    18 0E4F 00 00		number			.word	;Public
    19 0E51 00			the_cart_mode		.byte	;Public
    20 0E52 00 00		start_bank_number	.word	;Public
    21 0E54 00 00		initial_bank_number	.word	;Public
    22 0E56 00 00		loader_base_address	.word	;Public
    23 0E58 00			source_type		.byte	;Public
    24 0E59 00			item_menu_version	.byte	;Public
    25 0E5A 00			item_number		.byte	;Public
    26 0E5B 00			genre_number		.byte	;Public
    27 					.endl
    28
    29 					.if * >= $1000
    30 					.error "Selected entry is in the memory area the is use by the simple menu start routines ", *
    31 					.endif
    32
    33 				;===============================================================
    34
    35 0E5C				.proc init
    36 0E5C 20 65 0E			jsr clear_cursor
    37 0E5F A9 00			lda #0
    38 0E61 8D 4E 0E			sta selected_genre.number
    39 0E64 60				rts	
    40 					.endp
    41 					
    42 				;===============================================================
    43
    44 0E65				.proc clear_cursor
    45 0E65 A9 00			lda #0
    46 0E67 8D 4A 0E			sta cursor_line
    47 0E6A 8D 4B 0E			sta cursor_line+1
    48 0E6D A9 FF			lda #$ff
    49 0E6F 8D 4C 0E			sta last_cursor_line
    50 0E72 8D 4D 0E			sta last_cursor_line+1
    51 0E75 60				rts
    52 					.endp
    53
    54 				;===============================================================
    55
    56 0E76				.proc move_cursor
    57
    58 0E76				.var stick 		 .byte	;Working copy for shifting
    59 0E76				.var stick_step	 	 .word	;Make byte a word
    60 0E76				.var maximum_cursor_line .word
    61
    62 0E76 AD 15 10			lda input.input_help_mode
    63 0E79 D0 15			bne help_mode_active
    64
    65 0E7B 20 85 0D			jsr controls.read
    66 0E7E AD 72 0D 8D 40 0F		mva controls.stick stick		;Create working copy for shifting
    67 0E84 AD 74 0D 8D 41 0F		mva controls.stick_step+1 stick_step	;Create word based on hight byte
    68
    69 0E8A 20 91 0E			jsr handle_up_down
    70 0E8D 20 17 0F			jsr handle_left_right
    71 0E90			help_mode_active
    72 0E90 60				rts
    73
    74 				;===============================================================
    75
    76 0E91				.proc handle_up_down		 ;IN: <stick>, <stick_step>
    77 0E91 38 A5 E4 E9 01 8D + 	sbw result.found_entry_index #1 maximum_cursor_line
    78
    79 0EA0 4E 40 0F			lsr stick
    80 0EA3 B0 1D			bcs not_up
    81 0EA5 38 AD 4A 0E ED 41 + 	sbw cursor_line stick_step
    82 0EB8 B0 08			bcs up_ok
    83 0EBA A9 00			lda #0				;Underflow, set to zero
    84 0EBC 8D 4A 0E			sta cursor_line
    85 0EBF 8D 4B 0E			sta cursor_line+1
    86 0EC2			up_ok
    87 0EC2 4E 40 0F		not_up	lsr stick
    88 0EC5 B0 2F			bcs not_down
    89 0EC7 18 AD 4A 0E 6D 41 + 	adw cursor_line stick_step
    90 0EDA AD 4B 0E CD 44 0F + 	cpw cursor_line maximum_cursor_line
    91 0EE8 90 0C			bcc down_ok			;Overflow, set to last line
    92 0EEA AD 43 0F 8D 4A 0E + 	mwa maximum_cursor_line cursor_line
    93 0EF6			down_ok
    94 0EF6			not_down
    95 0EF6 AD 4B 0E CD 4D 0E + 	cpw cursor_line last_cursor_line
    96 0F04 D0 01			bne different_line
    97 0F06 60				rts
    98
    99 0F07			different_line
   100 0F07 AD 4A 0E 8D 4C 0E + 	mwa cursor_line last_cursor_line
   101 0F13 20 45 0F			jsr cursor.get_selected_entry
   102 0F16 60				rts
   103 					.endp				;End of handle_up_down
   104
   105 				;===============================================================
   106
   107 0F17				.proc handle_left_right		 ;IN: <stick>, <stick_step>
   108 0F17 AE 4E 0E			ldx selected_genre.number
   109
   110 0F1A 4E 40 0F			lsr stick
   111 0F1D B0 05			bcs not_left
   112 0F1F E0 00			cpx #0
   113 0F21 F0 01			beq not_left_limit
   114 0F23 CA				dex
   115 0F24			not_left_limit
   116 0F24			not_left
   117 0F24 4E 40 0F			lsr stick
   118 0F27 B0 07			bcs not_right
   119 0F29 E8				inx
   120 0F2A E4 A4			cpx menu_mcb.menu_genres_count
   121 0F2C B0 01			bcs not_right_limit
   122 0F2E E8				inx
   123 0F2F			not_right_limit
   124 0F2F CA				dex
   125 0F30			not_right
   126 0F30 EC 4E 0E			cpx selected_genre.number
   127 0F33 8E 4E 0E			stx selected_genre.number
   128 0F36 D0 01			bne different_genre
   129 0F38 60				rts
   130
   131 0F39			different_genre
   132 0F39 20 6B 1A			jsr visualization.menu.print_selected_genre
   133 0F3C 20 15 0A			jsr result.start_search_for_input
   134 0F3F 60				rts
   135 					.endp				;End of handle_up_down
   136
   137 				;===============================================================
   138
   139 = 0F40 00		STICK
   139 = 0F41 00 00		STICK_STEP
   139 = 0F43 00 00		MAXIMUM_CURSOR_LINE
   139 					.endp				;End of move_cursor
   140
   141 				;===============================================================
   142
   143 0F45				.proc get_selected_entry
   144 					
   145 = 00EA				selected_entry_pointer	= result.top_entry_pointer	;Reuse result VBI variables
   146 = 00EC				menu_entry_number	= result.menu_entry_number
   147 = 00EE				bank_number		= result.bank_number
   148 = 00F0				bank_address		= result.bank_address
   149
   150 					.macro m_get_byte
   151 				 	ldy #menu_entry.:1
   152 					mva (bank_address),y selected_entry.:1
   153 					.endm
   154
   155 					.macro m_get_word
   156 				 	ldy #menu_entry.:1
   157 					mva (bank_address),y selected_entry.:1
   158 					iny
   159 					mva (bank_address),y selected_entry.:1+1
   160 					.endm
   161
   162 0F45 A5 E4			lda result.found_entry_index
   163 0F47 05 E5			ora result.found_entry_index+1
   164 0F49 D0 13			bne some_entries_found
   165
   166 0F4B 85 EA			sta selected_entry_pointer	;Nothing found, so nothing can be selected.
   167 0F4D 85 EB			sta selected_entry_pointer+1
   168 0F4F 85 EC			sta menu_entry_number
   169 0F51 85 ED			sta menu_entry_number+1
   170 0F53 85 EE			sta bank_number
   171 0F55 85 EF			sta bank_number+1
   172 0F57 85 F0			sta bank_address
   173 0F59 85 F1			sta bank_address+1
   174 0F5B 4C 11 10			jmp print_selected_entry
   175
   176 0F5E			some_entries_found
   177 0F5E				m_convert_found_entry_index cursor.cursor_line selected_entry_pointer
Macro: EXTENDED_MENU.M_CONVERT_FOUND_ENTRY_INDEX [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm]
     1 0F5E AD 4A 0E 85 EA AD + 	mwa CURSOR.CURSOR_LINE SELECTED_ENTRY_POINTER
     2 0F68 06 EA			asl SELECTED_ENTRY_POINTER
     3 0F6A 26 EB			rol SELECTED_ENTRY_POINTER+1
     4 0F6C A5 EB			lda SELECTED_ENTRY_POINTER+1
     5 0F6E 69 3C			adc #>found_entries
     6 0F70 85 EB			sta SELECTED_ENTRY_POINTER+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   178
   179 0F72 A0 00			ldy #0
   180 0F74 B1 EA			lda (selected_entry_pointer),y
   181 0F76 85 EC			sta menu_entry_number
   182 0F78 C8				iny
   183 0F79 B1 EA			lda (selected_entry_pointer),y
   184 0F7B 85 ED			sta menu_entry_number+1
   185
   186 0F7D				m_convert_menu_entry_number 0
Macro: EXTENDED_MENU.M_CONVERT_MENU_ENTRY_NUMBER [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm]
     6 0F7D A5 EC			lda menu_entry_number
     7 0F7F 0A				asl
     8 0F80 A5 ED			lda menu_entry_number+1
     9 0F82 2A				rol
    10 0F83 85 EE			sta bank_number
    11 0F85 A9 00			lda #0
    12 0F87 85 F0			sta bank_address
    13 0F89 2A				rol
    14 0F8A 85 EF			sta bank_number+1
    16 0F8C 18 A5 EE 65 AA 85 + 	adw bank_number menu_mcb.menu_entries_start_bank_number 
    18 0F99 A5 EC			lda menu_entry_number
    19 0F9B 29 7F			and #$7f
    20 0F9D 4A				lsr
    21 0F9E 66 F0			ror bank_address
    22 0FA0 4A				lsr
    23 0FA1 66 F0			ror bank_address
    24 0FA3 18				clc
    25 0FA4 69 A0			adc #>module_a000
    26 0FA6 85 F1			sta bank_address+1
    28 0FA8 18 A5 F0 69 00 85 + 	adw bank_address #0
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   187
   188 0FB3 A6 EE			ldx bank_number	
   189 0FB5 A4 EF			ldy bank_number+1
   190 0FB7 20 D6 07			jsr menu_core.set_bank
   191
   192 0FBA				m_get_word number
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FBA A0 00		 	ldy #menu_entry.NUMBER
     2 0FBC B1 F0 8D 4F 0E		mva (bank_address),y selected_entry.NUMBER
     3 0FC1 C8				iny
     4 0FC2 B1 F0 8D 50 0E		mva (bank_address),y selected_entry.NUMBER+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   193 0FC7				m_get_byte the_cart_mode
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FC7 A0 02		 	ldy #menu_entry.THE_CART_MODE
     2 0FC9 B1 F0 8D 51 0E		mva (bank_address),y selected_entry.THE_CART_MODE
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   194 0FCE			 	m_get_word start_bank_number
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FCE A0 04		 	ldy #menu_entry.START_BANK_NUMBER
     2 0FD0 B1 F0 8D 52 0E		mva (bank_address),y selected_entry.START_BANK_NUMBER
     3 0FD5 C8				iny
     4 0FD6 B1 F0 8D 53 0E		mva (bank_address),y selected_entry.START_BANK_NUMBER+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   195 0FDB			 	m_get_word initial_bank_number
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FDB A0 06		 	ldy #menu_entry.INITIAL_BANK_NUMBER
     2 0FDD B1 F0 8D 54 0E		mva (bank_address),y selected_entry.INITIAL_BANK_NUMBER
     3 0FE2 C8				iny
     4 0FE3 B1 F0 8D 55 0E		mva (bank_address),y selected_entry.INITIAL_BANK_NUMBER+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   196 0FE8			 	m_get_word loader_base_address
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FE8 A0 08		 	ldy #menu_entry.LOADER_BASE_ADDRESS
     2 0FEA B1 F0 8D 56 0E		mva (bank_address),y selected_entry.LOADER_BASE_ADDRESS
     3 0FEF C8				iny
     4 0FF0 B1 F0 8D 57 0E		mva (bank_address),y selected_entry.LOADER_BASE_ADDRESS+1
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   197 0FF5			 	m_get_byte source_type
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FF5 A0 0A		 	ldy #menu_entry.SOURCE_TYPE
     2 0FF7 B1 F0 8D 58 0E		mva (bank_address),y selected_entry.SOURCE_TYPE
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   198 0FFC			 	m_get_byte item_menu_version
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 0FFC A0 0B		 	ldy #menu_entry.ITEM_MENU_VERSION
     2 0FFE B1 F0 8D 59 0E		mva (bank_address),y selected_entry.ITEM_MENU_VERSION
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   199 1003			 	m_get_byte item_number
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 1003 A0 0C		 	ldy #menu_entry.ITEM_NUMBER
     2 1005 B1 F0 8D 5A 0E		mva (bank_address),y selected_entry.ITEM_NUMBER
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   200 100A			 	m_get_byte genre_number
Macro: EXTENDED_MENU.CURSOR.GET_SELECTED_ENTRY.M_GET_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm]
     1 100A A0 36		 	ldy #menu_entry.GENRE_NUMBER
     2 100C B1 F0 8D 5B 0E		mva (bank_address),y selected_entry.GENRE_NUMBER
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Cursor.asm
   201
   202 1011			print_selected_entry
   203 1011 20 A0 1A			jsr visualization.menu.print_selected_entry
   204 1014 60				rts
   205
   206 					.endp				;End of get_selected_entry
   207
   208 					.endp				;End of cursor
   209
   796
   797 1015				icl "TheMenu-Input.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Input.asm
     1
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 1015				.proc input			;Handle keyboard input
     7
     8 = 3028			input_sm	= sm+screen_width
     9 = 0028			input_max_length = screen_width
    10
    11 1015 00			input_help_mode	.byte 0
    12 1016 00			input_started	.byte 0
    13 1017 00			input_changed	.byte 0
    14 1018 00			input_length	.byte 0
    15 1019 00			input_blink	.byte 0
    16 = 101A			input_buffer	.ds screen_width
    17
    18 				;===============================================================
    19
    20 1042				.proc init
    21
    22 1042 A0 00			ldy #0
    23 1044 8C 15 10			sty input_help_mode
    24 1047 8C 16 10			sty input_started
    25 104A 8C 17 10			sty input_changed
    26 104D 8C 18 10			sty input_length
    27 1050 8C 19 10			sty input_blink
    28
    29 1053 4E D9 02			lsr krpdel			;Half the time to wait for repeat
    30 1056 4E DA 02			lsr keyrep			;Twice the speed to repeat
    31 1059 60				rts
    32 					.endp
    33
    34 				;===============================================================
    35
    36
    37 105A				.proc handle_keys		;Called in VBI
    38
    39 105A				.proc blink_cursor
    40 105A EE 19 10			inc input_blink			;Increment blinking phase
    41 105D AD 19 10			lda input_blink			;Compute <C>=slow blinking
    42 1060 4A				lsr
    43 1061 4A				lsr
    44 1062 4A				lsr
    45 1063 4A				lsr
    46 1064 4A				lsr
    47 1065 A9 A0			lda #$80+' '			;Default cursor is inverse
    48 1067 90 02			scc
    49 1069 49 80			eor #$80			;Blinking cursor is not
    50 106B AC 18 10			ldy input_length
    51 106E C0 28			cpy #input_max_length		;Do not print cursor if line is full
    52 1070 B0 03			scs
    53 1072 99 28 30			sta input_sm,y			;Write to screen
    54 					.endp
    55
    56 1075 AC FC 02			ldy ch				;Any key pressed?
    57 1078 C0 FF			cpy #$ff
    58 107A D0 17			bne normal_key_pressed
    59 107C AC DC 02			ldy helpfg
    60 107F D0 01			bne help_key_pressed
    61 1081 60				rts
    62
    63 1082				.proc help_key_pressed
    64 1082 A2 00			ldx #$00			;Clear HELP key flag
    65 1084 8E DC 02			stx helpfg
    66
    67 1087 AD 15 10			lda input_help_mode		;Toggle help mode
    68 108A 49 FF			eor #$ff
    69 108C 8D 15 10			sta input_help_mode
    70
    71 108F 20 A6 19			jsr visualization.menu.toggle_help_mode
    72 1092 60				rts
    73 					.endp
    74
    75 1093				.proc normal_key_pressed
    76 1093 A2 FF			ldx #$ff			;Clear key code
    77 1095 8E FC 02			stx ch
    78
    79 1098 AD 15 10			lda input_help_mode		;If help mode is active, any key first deactivates help mode
    80 109B D0 E5			bne help_key_pressed
    81
    82 109D B9 3A 11			lda key_definitions,y		;Convert key code to ASCII
    83 10A0 C9 9B			cmp #$9b			;Do not convert RETURN
    84 10A2 F0 02			seq
    85 10A4 29 7F			and #127			;Mask out inverse bit
    86
    87 10A6				.proc check_ignored_keys
    88 10A6 A2 08			ldx #(.len ignored_keys)-1	;Check if the ASCII value is on the list of keys to ignore
    89 10A8 DD FA 11		loop	cmp ignored_keys,x
    90 10AB D0 01			sne
    91 10AD 60				rts				;Return if ignored key is found
    92
    93 10AE CA				dex
    94 10AF 10 F7			bpl loop			;Check next ignored key
    95 					.endp
    96
    97 10B1				.proc click			;Identical code from OS, but shorter
    98 10B1 A2 6E			ldx #$6e
    99 10B3 8E 1F D0		loop	stx consol
   100 10B6 AC 0B D4			ldy vcount
   101 10B9 CC 0B D4		wait	cpy vcount
   102 10BC F0 FB			beq wait
   103 10BE CA				dex
   104 10BF CA				dex
   105 10C0 10 F1			bpl loop
   106 					.endp
   107
   108 10C2				.proc check_first_key		;Clear the welcome message on first key
   109 10C2 48				pha
   110 10C3 AD 16 10			lda input_started
   111 10C6 D0 06			bne skip
   112 10C8 EE 16 10			inc input_started
   113 10CB 20 FC 19			jsr visualization.menu.clear_welcome
   114 10CE			skip
   115 10CE 68				pla
   116 					.endp
   117 					
   118 10CF C9 7F			cmp #$7f			;"TAB"
   119 10D1 D0 04			bne no_tab
   120 10D3 20 5F 1A			jsr visualization.menu.toggle_details_mode
   121 10D6 60				rts
   122
   123 10D7			no_tab
   124 10D7 C9 1B			cmp #27				;"ESC"
   125 10D9 D0 06			bne no_escape
   126 10DB A9 01 8D 65 0D		mva #search.status.start_simple_menu search.search_status
   127 10E0 60				rts
   128
   129 10E1			no_escape
   130 10E1 C9 7E			cmp #126			;"BACKSPACE"
   131 10E3 D0 21			bne no_backspace
   132 10E5 AC 18 10			ldy input_length
   133 10E8 F0 1B			beq backspace_done
   134 10EA CE 18 10			dec input_length		;Move left
   135 10ED A2 00 8E 19 10		mvx #0 input_blink		;Keep cursor visible
   136 10F2 A2 01 8E 17 10		mvx #1 input_changed		;Indicate new search required
   137
   138 10F7 A9 A0			lda #$80+' '
   139 10F9 99 27 30			sta input_sm-1,y		;Print cursor
   140 10FC C0 28			cpy #input_max_length
   141 10FE F0 05			beq backspace_done
   142 1100 A9 20			lda #' '			;Clear previous cursor position
   143 1102 99 28 30			sta input_sm,y
   144
   145 1105			backspace_done
   146 1105 60				rts
   147
   148 1106			no_backspace
   149 1106 AC 18 10			ldy input_length
   150 1109 C0 28			cpy #input_max_length
   151 110B F0 2C			beq text_input_done
   152 110D EE 18 10			inc input_length		;Move right
   153 1110 A2 00 8E 19 10		mvx #0 input_blink
   154 1115 A2 01 8E 17 10		mvx #1 input_changed
   155
   156 111A C9 20			cmp #$20			;Convert to uppercase
   157 111C B0 02			bcs no_control
   158 111E 69 40			adc #$40
   159 1120			no_control
   160 1120 C9 61			cmp #'a'
   161 1122 90 06			bcc no_lower_case
   162 1124 C9 7B			cmp #'z'+1
   163 1126 B0 02			bcs no_lower_case
   164 1128 E9 1F			sbc #$20-1
   165 112A			no_lower_case
   166 112A 99 1A 10			sta input_buffer,y		;Write to buffer
   167 112D 99 28 30			sta input_sm,y			;Print character
   168 1130 C0 27			cpy #input_max_length-1		;Enough space for cursor?
   169 1132 F0 05			beq text_input_done
   170 1134 A9 A0			lda #$80+' '			;Print new cursor position
   171 1136 99 29 30			sta input_sm+1,y
   172
   173 1139			text_input_done
   174 1139 60				rts
   175
   176 				;===============================================================
   177
   178 113A				.local key_definitions		;Directly included, so the menu also works with the OldRunner OS
   179 113A 6C 6A 3B 8A 8B 6B + 	ins "TheMenu-Input-Key-Definitions.bin"
   180 					.end
   181 					
   182 11FA				.local ignored_keys		;ASCII values of keys that should be ignored
   183 11FA 1C				.byte 28			;Ignore "CURSOR UP" with control
   184 11FB 2D				.byte '-'			;Ignore "CURSOR UP" without control
   185 11FC 1D				.byte 29			;Ignore "CURSOR DOWN" with control
   186 11FD 3D				.byte '='			;Ignore "CURSOR DOWN" without control
   187
   188 11FE 1E				.byte 30			;Ignore "CURSOR UP" with control
   189 11FF 2B				.byte '+'			;Ignore "CURSOR UP" without control
   190 1200 1F				.byte 31			;Ignore "CURSOR DOWN" with control
   191 1201 2A				.byte '*'			;Ignore "CURSOR DOWN" without control
   192
   193 1202 9B				.byte $9b			;Ignore "RETURN"
   194 					.endl
   195
   196 				;===============================================================
   197
   198 					.endp				;End of normal_key_pressed
   199 					.endp				;End of handle_keys
   200
   201 					.endp		;End of input
   798
   799 1203				icl "TheMenu-Visualization.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
     1
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 				;===============================================================
     7
     8 1203				.proc visualization
     9
    10 = 0003			result_dli	= 3
    11
    12 = 0014			cnt		= $14	;OS frame counter
    13
    14 1203				.proc screen
    15
    16 1203				.var vdslst_old .word
    17
    18 1203				.proc init
    19 1203 A9 64 8D 30 02 A9 + 	mwa #dl sdlstl			;Setup display
    20 120D AD 00 02 8D 38 19 + 	mwa vdslst vdslst_old		;Save old DLI vector
    21 1219 A9 20 8D 00 02 A9 + 	mwa #nmi.dli vdslst		;Activate DLI
    22
    23 1223 A9 00			lda #$00
    24 1225 8D C8 02			sta color4
    25
    26 1228 A9 0E			lda #14
    27 122A 8D C0 02			sta pcolor0			;White border (PM)
    28 122D 8D C1 02			sta pcolor1			;White border (PM)
    29 1230 8D C4 02			sta color0			;White border (SM)
    30
    31 1233 A9 0C			lda #12
    32 1235 8D C7 02			sta color3			;Header
    33 1238 8D A3 14			sta screen.colors.colpf1	;First line
    34 123B 8D A4 14			sta screen.colors.colpf1+1	;Second line
    35 123E A9 0E			lda #14
    36 1240 8D A5 14			sta screen.colors.colpf1+2	;Third line
    37 1243 A9 0C			lda #12
    38 1245 8D BA 14			sta screen.colors.colpf1+23	;First status line
    39 1248 8D BB 14			sta screen.colors.colpf1+24	;Second status line
    40
    41 124B A9 72			lda #$72
    42 124D 8D BC 14			sta screen.colors.colpf2
    43 1250 69 02			adc #$02
    44 1252 8D BD 14			sta screen.colors.colpf2+1
    45 1255 69 02			adc #$02
    46 1257 8D BE 14			sta screen.colors.colpf2+2
    47 125A A9 72			lda #$72
    48 125C 8D D3 14			sta screen.colors.colpf2+23
    49 125F 8D D4 14			sta screen.colors.colpf2+24
    50
    51 = 001E				pm_offset = $1e			;Setup PM border lines
    52 = 00CE				pm_lines = 206
    53 1262 A9 28 8D 07 D4		mva #>pm pmbase
    54 1267 A9 03 8D 1D D0		mva #3 gractl
    55 126C A9 2F 8D 00 D0		mva #$2f hposp0
    56 1271 A9 D0 8D 01 D0		mva #$d0 hposp1
    57 1276 A9 00			lda #0
    58 1278 AA				tax
    59 1279			clear_pm
    60 1279 9D 00 2C			sta pm+$400,x
    61 127C 9D 00 2D			sta pm+$500,x
    62 127F E8				inx
    63 1280 D0 F7			bne clear_pm
    64 1282 A9 80			lda #$80
    65 1284			fill_pm
    66 1284 9D 1E 2C			sta pm+$400+pm_offset,x
    67 1287 9D 1E 2D			sta pm+$500+pm_offset,x
    68 128A E8				inx
    69 128B E0 CE			cpx #pm_lines
    70 128D D0 F5			bne fill_pm
    71
    72 128F A2 00			ldx #0
    73 1291			copy_chr				;Create ASCII charset layout
    74 1291 BD 00 E0			lda $e000,x
    75 1294 9D 00 25			sta chr+$100,x
    76 1297 BD 00 E1			lda $e100,x
    77 129A 9D 00 26			sta chr+$200,x
    78 129D BD 00 E2			lda $e200,x
    79 12A0 9D 00 24			sta chr+$000,x
    80 12A3 BD 00 E3			lda $e300,x
    81 12A6 9D 00 27			sta chr+$300,x
    82 12A9 E8				inx
    83 12AA D0 E5			bne copy_chr
    84
    85 12AC A9 20			lda #' '
    86 12AE			clear_sm
    87 12AE 9D 00 30			sta sm,x			;Clear screen
    88 12B1 9D 00 31			sta sm+$100,x
    89 12B4 9D 00 32			sta sm+$200,x
    90 12B7 9D 00 33			sta sm+$300,x
    91 12BA E8				inx
    92 12BB D0 F1			bne clear_sm
    93 12BD 60				rts
    94 					.endp
    95
    96 				;===============================================================
    97
    98 12BE				.proc activate
    99 12BE A9 3E 8D 2F 02		mva #$3e sdmctl			;Activate screen in next frame
   100 12C3 60				rts
   101 					.endp
   102
   103 				;===============================================================
   104
   105 12C4				.proc exit
   106 12C4 A9 40 8D 0E D4		mva #$40 nmien			;Disable DLIs
   107 12C9 AD 38 19 8D 00 02 + 	mwa vdslst_old vdslst		;Restore original DLI vector
   108
   109 12D5 A9 00			lda #0				;Hide PMs
   110 12D7 8D 00 D0			sta hposp0
   111 12DA 8D 01 D0			sta hposp1
   112 12DD 8D C0 02			sta pcolor0			;Reset PM colors
   113 12E0 8D C1 02			sta pcolor1
   114 12E3 8D 1D D0			sta gractl			;Reset PM graphics
   115 12E6 8D 0D D0			sta grafp0
   116 12E9 8D 0E D0			sta grafp1	
   117 12EC 60				rts
   118
   119 					.endp
   120
   121 				;===============================================================
   122
   123 12ED				.proc nmi
   124
   125 12ED				.proc vbi
   126 12ED A9 00 8D 27 13		mva #0 dli.count
   127 12F2 A9 00			lda #0
   128 12F4 8D 45 13			sta dli.cursor_color1
   129 12F7 A5 14			lda cnt
   130 12F9 4A				lsr
   131 12FA 4A				lsr
   132 12FB 29 0F			and #15
   133 12FD AA				tax
   134 12FE E0 08			cpx #.len colors
   135 1300 90 02			scc
   136 1302 A2 00			ldx #0
   137 1304 BD 18 13			lda colors,x
   138 1307 8D 4A 13			sta dli.cursor_color2
   139
   140 130A A5 13			lda $13
   141 130C 4A				lsr
   142 130D A5 14			lda cnt
   143 130F 6A				ror	
   144 1310 29 F0			and #$f0
   145 1312 09 0C			ora #12
   146 1314 8D C7 02			sta color3
   147 1317 60				rts
   148 					
   149 1318				.local colors
   150 1318 0C 0C 0C 0A 08 06 + 	.byte 12,12,12,10,8,6,8,10
   151 					.endl
   152 					.endp
   153
   154 				;===============================================================
   155
   156 1320				.proc dli
   157 1320 48				pha
   158 1321 8A				txa
   159 1322 48				pha
   160 1323 8D 0A D4			sta wsync
   161 = 1327			count = *+1
   162 1326 A2 00			ldx #0
   163 = 1329			cursor_line = *+1
   164 1328 E0 FF			cpx #$ff
   165 132A F0 18			beq set_cursor
   166 = 132D			colpf1_adr = *+1
   167 132C BD A3 14			lda screen.colors.colpf1,x
   168 132F 8D 17 D0			sta colpf1
   169 = 1333			colpf2_adr = *+1
   170 1332 BD BC 14			lda screen.colors.colpf2,x
   171 1335 8D 18 D0			sta colpf2
   172 1338 A9 24			lda #>chr		;Activate ASCII charset
   173 133A 8D 09 D4			sta chbase
   174 133D EE 27 13		dli_end	inc count
   175 1340 68				pla
   176 1341 AA				tax
   177 1342 68				pla
   178 1343 40				rti
   179
   180 1344			set_cursor
   181
   182 = 1345			cursor_color1 = *+1
   183 1344 A9 00			lda #0
   184 1346 8D 17 D0			sta colpf1
   185 = 134A			cursor_color2 = *+1
   186 1349 A9 00			lda #0
   187 134B 8D 18 D0			sta colpf2
   188 134E 4C 3D 13			jmp dli_end
   189
   190 					.endp			;End of dli
   191
   192 					.endp			;End of nmi
   193 				 
   194 				;===============================================================
   195
   196 1351				.align $400
   197
   198 1400				.local header	
   199 1400 00 00 00 00 00 00		.byte "      ";
   200 1406 F4 E8 E5 C1 E3 E1 + 	.by +$a0 "THE!CART"
   201 140E 00 00 00 00 00 00		.byte "      "
   202 					.endl
   203
   204 1414				.local line
   205 1414 55 55 55 55 55 55 + :40	.byte $55
   206 					.endl
   207
   208 143C				.local welcome
   209 143C 20 20 57 65 6C 63 + 	.byte '  Welcome! Press HELP for instructions. '
   210 					.endl
   211
   212 1464				.local dl
   213 1464 60 46 00 14 E0		.byte $60,$46,a(header),$80+$60
   214 1469 4E 14 14			.byte $4e,a(line)
   215 146C C2 00 30			.byte $80+$42,a(sm)
   216 146F 4E 14 14			.byte $4e,a(line)
   217 1472 C2 28 30			.byte $80+$42,a(sm+screen_width*1)
   218 1475 4E 14 14			.byte $4e,a(line)
   219 1478 C2 00 38			.byte $80+$42,a(genre_sm)
   220 147B 4E 14 14			.byte $4e,a(line)
   221 147E C2 50 30			.byte $80+$42,a(sm+screen_width*2)
   222 1481 82 82 82 82 82 82 + :19	.byte $80+$02
   223 1494 4E 14 14			.byte $4e,a(line)
   224 1497 C2 70 33			.byte $80+$42,a(sm+screen_width*22)
   225 = 149B			welcome_lms = *+1
   226 149A 42 3C 14			.byte $00+$42,a(welcome)
   227 149D 4E 14 14			.byte $4e,a(line)
   228 14A0 41 64 14			.byte $41,a(dl)
   229 					.endl
   230
   231 14A3				m_assert_same_1k dl
Macro: M_ASSERT_SAME_1K [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "DL within 1k boundary between ", DL , " - ", DL + [.len DL ] - 1
     8 				DL within 1k boundary between $1464 - $14A2
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   232
   233 14A3				.local colors
   234 14A3				.local colpf1
   235 14A3 00 00 00 00 00 00 + :screen_lines	.byte 0
   236 					.endl
   237 14BC				m_assert_same_page colpf1
Macro: M_ASSERT_SAME_PAGE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "COLPF1 within page boundary between ", COLPF1, " - ", COLPF1 + .len COLPF1 - 1
     8 				COLPF1 within page boundary between $D017 - $D016
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   238
   239 14BC				.local colpf2
   240 14BC 00 00 00 00 00 00 + :screen_lines	.byte 0
   241 					.endl
   242 					.endl
   243
   244 14D5				m_assert_same_page colpf2
Macro: M_ASSERT_SAME_PAGE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "COLPF2 within page boundary between ", COLPF2, " - ", COLPF2 + .len COLPF2 - 1
     8 				COLPF2 within page boundary between $D018 - $D017
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   245
   246 14D5				.local help_dl			;Help screen display list
   247
   248 					.macro m_empty_4_lines
   249 					.byte $4f,a(help_sm.empty_line)
   250 					.byte $4f,a(help_sm.empty_line)
   251 					.byte $4f,a(help_sm.empty_line)
   252 					.byte $80+$4f,a(help_sm.empty_line)
   253 					.endm
   254
   255 14D5 60 46 00 14 E0		.byte $60,$46,a(header),$80+$60
   256 14DA 4E 14 14			.byte $4e,a(line)
   257 14DD C2 8E 15			.byte $80+$42,a(help_sm)
   258 14E0 4E 14 14			.byte $4e,a(line)
   259 14E3 C2 B6 15			.byte $80+$42,a(help_sm+screen_width*1)
   260 14E6 4E 14 14			.byte $4e,a(line)
   261 14E9 C2 DE 15			.byte $80+$42,a(help_sm+screen_width*2)
   262 14EC 4E 14 14			.byte $4e,a(line)
   263 14EF				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 14EF 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 14F2 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 14F5 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 14F8 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   264 14FB C2 06 16			.byte $80+$42,a(help_sm+screen_width*3)
   265 14FE C2 2E 16			.byte $80+$42,a(help_sm+screen_width*4)
   266 1501				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1501 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 1504 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1507 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 150A CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   267 150D				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 150D 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 1510 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1513 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 1516 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   268 1519 C2 56 16			.byte $80+$42,a(help_sm+screen_width*5)
   269 151C C2 7E 16			.byte $80+$42,a(help_sm+screen_width*6)
   270 151F				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 151F 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 1522 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1525 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 1528 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   271 152B				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 152B 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 152E 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1531 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 1534 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   272 1537 C2 A6 16			.byte $80+$42,a(help_sm+screen_width*7)
   273 153A C2 CE 16			.byte $80+$42,a(help_sm+screen_width*8)
   274 153D C2 F6 16			.byte $80+$42,a(help_sm+screen_width*9)
   275 1540				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1540 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 1543 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1546 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 1549 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   276 154C				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 154C 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 154F 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1552 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 1555 CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   277 1558 C2 1E 17			.byte $80+$42,a(help_sm+screen_width*10)
   278 155B C2 46 17			.byte $80+$42,a(help_sm+screen_width*11)
   279 155E C2 6E 17			.byte $80+$42,a(help_sm+screen_width*12)
   280 1561 C2 96 17			.byte $80+$42,a(help_sm+screen_width*13)
   281 1564 C2 BE 17			.byte $80+$42,a(help_sm+screen_width*14)
   282 1567 C2 E6 17			.byte $80+$42,a(help_sm+screen_width*15)
   283 156A C2 0E 18			.byte $80+$42,a(help_sm+screen_width*16)
   284 156D C2 36 18			.byte $80+$42,a(help_sm+screen_width*17)
   285 1570 C2 5E 18			.byte $80+$42,a(help_sm+screen_width*18)
   286 1573				m_empty_4_lines
Macro: EXTENDED_MENU.VISUALIZATION.SCREEN.HELP_DL.M_EMPTY_4_LINES [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1573 4F D6 18			.byte $4f,a(help_sm.empty_line)
     2 1576 4F D6 18			.byte $4f,a(help_sm.empty_line)
     3 1579 4F D6 18			.byte $4f,a(help_sm.empty_line)
     4 157C CF D6 18			.byte $80+$4f,a(help_sm.empty_line)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   287 157F 4E 14 14			.byte $4e,a(line)
   288 1582 C2 86 18			.byte $80+$42,a(help_sm+screen_width*19)
   289 1585 42 AE 18			.byte $00+$42,a(help_sm+screen_width*20)
   290 1588 4E 14 14			.byte $4e,a(line)
   291 158B 41 D5 14			.byte $41,a(help_dl)
   292 					.endl
   293
   294 158E				m_assert_same_1k help_dl
Macro: M_ASSERT_SAME_1K [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "HELP_DL within 1k boundary between ", HELP_DL , " - ", HELP_DL + [.len HELP_DL ] - 1
     8 				HELP_DL within 1k boundary between $14D5 - $158D
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   295
   296 158E				.local help_sm			;Help screen content
   297 158E 20 54 68 69 73 20 + 	.byte ' This line contains the workbook title. '
   298 15B6 20 20 54 68 69 73 + 	.byte '  This line contains the search term.   '
   299 15DE 20 20 54 68 69 73 + 	.byte '  This line contains the genre names.   '
   300 1606 20 20 20 57 65 6C + 	.byte '   Welcome to The!Cart extended menu.   '
   301 162E 20 20 59 6F 75 20 + 	.byte '  You can use the following controls.   '
   302 1656 20 4B 65 79 62 6F + 	.byte ' Keyboard to type the search term:      '
   303 167E 20 20 44 45 4C 45 + 	.byte '  DELETE          - Delete last input   '
   304 16A6 20 4B 65 79 62 6F + 	.byte ' Keyboard or joystick to select genre:  '
   305 16CE 20 20 4C 45 46 54 + 	.byte '  LEFT  or +      - Previous genre      '
   306 16F6 20 20 52 49 47 48 +  	.byte '  RIGHT or *      - Next genre          '
   307 171E 20 4B 65 79 62 6F + 	.byte ' Keyboard or joystick to select entry:  '
   308 1746 20 20 55 50 20 20 + 	.byte '  UP    or -      - Cursor line up      '
   309 176E 20 20 44 4F 57 4E + 	.byte '  DOWN  or =      - Cursor line down    '
   310 1796 20 20 46 49 52 45 + 	.byte '  FIRE  or RETURN - Start entry         '
   311 17BE 20 20 20 20 20 20 + 	.byte '      with CONTROL- Start entry''s menu  '
   312 17E6 20 20 20 20 20 20 + 	.byte '      with SHIFT  - Don''t lock The!Cart '
   313 180E 20 20 20 20 20 20 + 	.byte '                                        '
   314 1836 20 20 20 20 20 20 + 	.byte '                                        '
   315 185E 20 20 20 20 20 20 + 	.byte '                                        '
   316 1886 20 20 54 41 42 20 + 	.byte '  TAB             - Toggle details mode '
   317 18AE 20 20 20 54 68 65 + 	.byte '   The!Cart Studio by Peter Dell/JAC!   '
   318
   319 18D6				.local empty_line
   320 18D6 00 00 00 00 00 00 + :40	.byte 0
   321 					.endl	
   322 					.endl
   323
   324 18FE				.local help_colors		;Help screen text colors
   325 					
   326 18FE				.local colpf1
   327 18FE 0E 0E 0E 0E 0E 0E + :screen_lines+4	.byte 14
   328 					.endl
   329 191B				m_assert_same_page colpf1
Macro: M_ASSERT_SAME_PAGE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "COLPF1 within page boundary between ", COLPF1, " - ", COLPF1 + .len COLPF1 - 1
     8 				COLPF1 within page boundary between $D017 - $D016
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   330
   331 191B				.local colpf2
   332 191B 72 74 76			.byte $72,$74,$76
   333 191E 34 34 34 34			.byte $34,$34,$34,$34
   334 1922 44 44 44 44 54		.byte $44,$44,$44,$44,$54
   335 1927 54 54 54 54			.byte $54,$54,$54,$54
   336 192B 64 64 64 64 64 64 + 	.byte $64,$64,$64,$64,$64,$64,$64,$64,$64,$64,$64
   337 1936 72 72			.byte $72,$72
   338 					.endl
   339 1938				m_assert_same_page colpf2
Macro: M_ASSERT_SAME_PAGE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     8 						.print "COLPF2 within page boundary between ", COLPF2, " - ", COLPF2 + .len COLPF2 - 1
     8 				COLPF2 within page boundary between $D018 - $D017
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   340
   341 					.endl
   342
   343
   344 = 1938 00 00		VDSLST_OLD
   344 					.endp				;End of screen
   345
   346 193A				.proc print
   347
   348 = 3370				print_sm = sm+screen_width*22;
   349
   350 					.macro m_print_text
   351 					jmp skip
   352 				text	.byte ':1'
   353 					.byte 0
   354 				skip
   355 					lda print.print_text.text_adr	;Push for recursive call, low byte
   356 					pha
   357 					lda #<text
   358 					ldy #>text
   359 					jsr print.print_text
   360 					pla
   361 					sta print.print_text.text_adr	;Pull for recurive call, low byte
   362 					.endm
   363
   364 					.macro m_print_space
   365 					jsr print.print_space
   366 					.endm
   367
   368 					.macro m_print_byte
   369 					lda :1
   370 					jsr print.print_hex
   371 					.endm
   372
   373 					.macro m_print_word
   374 					lda :1+1
   375 					jsr print.print_hex
   376 					lda :1
   377 					jsr print.print_hex
   378 					.endm
   379
   380 193A				.proc print_text		;Low byte of text_adr must have been pushed before
   381 193A 8D 47 19			sta text_adr
   382 193D AD 48 19			lda text_adr+1			;Push for recursive call, high byte
   383 1940 48				pha
   384 1941 8C 48 19			sty text_adr+1
   385 1944 A0 00			ldy #0
   386 = 1947			text_adr = *+1
   387 1946 B9 FF FF		loop	lda $ffff,y
   388 1949 F0 0C			beq return
   389 194B 9D 70 33			sta print.print_sm,x
   390 194E E8				inx
   391 194F E0 51			cpx #81
   392 1951 90 01			scc
   393 1953				jam
Macro: JAM [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 1953 02				.byte $02
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   394
   395 1954 C8				iny
   396 1955 D0 EF			bne loop	
   397 1957 68			return	pla				;Pull for recursive call, high byte
   398 1958 8D 48 19			sta text_adr+1
   399 195B 60				rts
   400 					.endp
   401
   402 195C				.proc print_space
   403 195C A9 20			lda #' '
   404 195E 9D 70 33			sta print.print_sm,x
   405 1961 E8				inx
   406 1962 60				rts
   407 					.endp
   408
   409 1963				.proc print_hex
   410 					
   411 1963 8C 7F 19			sty save_y+1
   412 1966 48				pha
   413 1967 4A				lsr
   414 1968 4A				lsr
   415 1969 4A				lsr
   416 196A 4A				lsr
   417 196B A8				tay
   418 196C B9 81 19			lda hex_digits,y
   419 196F 9D 70 33			sta print_sm,x
   420 1972 E8				inx
   421 1973 68				pla
   422 1974 29 0F			and #15
   423 1976 A8				tay
   424 1977 B9 81 19			lda hex_digits,y
   425 197A 9D 70 33			sta print_sm,x
   426 197D E8				inx
   427 197E A0 00		save_y	ldy #0
   428 1980 60				rts
   429 					
   430 1981 30 31 32 33 34 35 + hex_digits	.byte '0123456789ABCDEF'
   431 					.endp
   432 					
   433 					.endp				;End of print
   434
   435 				;===============================================================
   436
   437 1991				.proc menu
   438
   439 1991				.var help_mode .byte
   440 1991				.var details_mode .byte
   441
   442 = 14A6				displayed_entries.color1 = screen.colors.colpf1+result_dli
   443 = 14BF				displayed_entries.color2 = screen.colors.colpf2+result_dli
   444
   445 				;===============================================================
   446
   447 1991				.proc init
   448 1991 A9 00			lda #0
   449 1993 8D A1 1B			sta help_mode
   450 1996 8D A2 1B			sta details_mode
   451 1999 60				rts
   452 					.endp
   453
   454 				;===============================================================
   455
   456 199A				.proc print_menu_title
   457 199A A0 27			ldy #screen_width-1
   458 199C B9 AC 00		loop	lda menu_mcb.menu_title,y
   459 199F 99 00 30			sta sm,y
   460 19A2 88				dey
   461 19A3 10 F7			bpl loop
   462 19A5 60				rts
   463 					.endp
   464
   465 				;===============================================================
   466
   467 19A6				.proc toggle_help_mode
   468 19A6				.var old_cursor_line .byte
   469
   470 19A6 AD 15 10			lda input.input_help_mode
   471 19A9 D0 25			bne help_active
   472 19AB A9 64 8D 30 02 A9 + 	mwa #screen.dl sdlstl		;Setup normal display
   473 19B5 A9 A3 8D 2D 13 A9 + 	mwa #screen.colors.colpf1 screen.nmi.dli.colpf1_adr
   474 19BF A9 BC 8D 33 13 A9 + 	mwa #screen.colors.colpf2 screen.nmi.dli.colpf2_adr
   475 19C9 AD FA 19 8D 29 13		mva old_cursor_line screen.nmi.dli.cursor_line 
   476 19CF 60				rts
   477
   478 19D0			help_active
   479 19D0 A9 D5 8D 30 02 A9 + 	mwa #screen.help_dl sdlstl	;Setup help display
   480 19DA A9 FE 8D 2D 13 A9 + 	mwa #screen.help_colors.colpf1 screen.nmi.dli.colpf1_adr
   481 19E4 A9 1B 8D 33 13 A9 + 	mwa #screen.help_colors.colpf2 screen.nmi.dli.colpf2_adr
   482 19EE AD 29 13 8D FA 19		mva screen.nmi.dli.cursor_line old_cursor_line
   483 19F4 A9 FF 8D 29 13		mva #$ff screen.nmi.dli.cursor_line
   484 19F9 60				rts
   485 = 19FA 00		OLD_CURSOR_LINE
   485 					.endp
   486
   487 				;===============================================================
   488
   489 19FB				.proc print_welcome
   490 19FB 60				rts
   491 					.endp
   492
   493 19FC				.proc clear_welcome
   494 19FC A9 98 8D 9B 14 A9 + 	mwa #(sm+screen_width*23) screen.dl.welcome_lms
   495 1A06 60				rts
   496 					.endp
   497
   498 1A07				.proc print_menu_entries_count
   499 1A07 A2 28			ldx #40
   500 1A09				print.m_print_text "Found:None/"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1A09 4C 18 1A			jmp skip
     2 1A0C 46 6F 75 6E 64 3A + text	.byte 'Found:None/'
     3 1A17 00				.byte 0
     4 1A18			skip
     5 1A18 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1A1B 48				pha
     7 1A1C A9 0C			lda #<text
     8 1A1E A0 1A			ldy #>text
     9 1A20 20 3A 19			jsr print.print_text
    10 1A23 68				pla
    11 1A24 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   501 1A27				print.m_print_word menu_mcb.menu_entries_count
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1A27 A5 A9			lda MENU_MCB.MENU_ENTRIES_COUNT+1
     2 1A29 20 63 19			jsr print.print_hex
     3 1A2C A5 A8			lda MENU_MCB.MENU_ENTRIES_COUNT
     4 1A2E 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   502 1A31 60				rts
   503 					.endp
   504
   505 1A32				.proc set_entry_colors		;IN: <X>=line
   506 1A32 A9 0E			lda #14	
   507 1A34 9D A6 14			sta displayed_entries.color1,x
   508
   509 1A37 BD A8 0B			lda result.displayed_entries.lo,x
   510 1A3A 0A				asl
   511 1A3B 0A				asl
   512 1A3C 0A				asl
   513 1A3D 0A				asl
   514 1A3E 09 04			ora #$04
   515 1A40 9D BF 14			sta displayed_entries.color2,x
   516 1A43 60				rts
   517 					.endp
   518
   519 1A44				.proc clear_entry_colors	;IN: <X>=line
   520 				;	lda #0
   521 				;	sta displayed_entries.color1,x
   522 				;	sta displayed_entries.color2,x
   523 1A44 BD A8 0B			lda result.displayed_entries.lo,x
   524 1A47 0A				asl
   525 1A48 0A				asl
   526 1A49 0A				asl
   527 1A4A 0A				asl
   528 1A4B 09 04			ora #$04
   529 1A4D 9D A6 14			sta displayed_entries.color1,x
   530 1A50 9D BF 14			sta displayed_entries.color2,x
   531 1A53 60				rts
   532 					.endp
   533
   534 				;===============================================================
   535
   536 1A54				.proc set_cursor_line		;IN: <A>=cursor line, $ff is not visible
   537 1A54 C9 FF			cmp #$ff
   538 1A56 F0 03			beq not_visible 
   539 1A58 18				clc
   540 1A59 69 03			adc #result_dli
   541 1A5B			not_visible
   542 1A5B 8D 29 13			sta screen.nmi.dli.cursor_line
   543 1A5E 60				rts
   544 					.endp
   545
   546 				;===============================================================
   547
   548 1A5F				.proc toggle_details_mode
   549 1A5F AD A2 1B			lda details_mode
   550 1A62 49 FF			eor #$ff
   551 1A64 8D A2 1B			sta details_mode
   552 1A67 20 A0 1A			jsr print_selected_entry
   553 1A6A 60				rts
   554 					.endp
   555
   556 				;===============================================================
   557
   558 1A6B				.proc print_selected_genre
   559 1A6B				.var inverse .byte
   560
   561 1A6B AD 4E 0E			lda cursor.selected_genre.number
   562 1A6E 0A				asl
   563 1A6F A8				tay
   564 1A70 B9 00 34 8D 84 1A + 	mwa genres_list,y print_adr
   565 					
   566 1A7C A9 80 8D 9F 1A		mva #$80 inverse
   567 1A81 A0 00			ldy #0
   568 1A83			loop
   569 = 1A84			print_adr = *+1
   570 1A83 B9 FF FF			lda $ffff,y
   571 1A86 D0 05			bne not_end
   572 1A88 0E 9F 1A			asl inverse
   573 1A8B A9 20			lda #' '
   574 1A8D C9 FF		not_end	cmp #$ff
   575 1A8F D0 02			bne not_ff
   576 1A91 A9 20			lda #' '
   577 1A93 0D 9F 1A		not_ff	ora inverse
   578 1A96 99 00 38			sta genre_sm,y
   579 1A99 C8				iny
   580 1A9A C0 28			cpy #screen_width
   581 1A9C D0 E5			bne loop
   582 1A9E 60				rts
   583 = 1A9F 00		INVERSE
   583 					.endp
   584
   585 				;===============================================================
   586
   587 1AA0				.proc print_selected_entry
   588 1AA0 A2 00			ldx #0
   589 1AA2				print.m_print_text "Entry:"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1AA2 4C AC 1A			jmp skip
     2 1AA5 45 6E 74 72 79 3A	text	.byte 'Entry:'
     3 1AAB 00				.byte 0
     4 1AAC			skip
     5 1AAC AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1AAF 48				pha
     7 1AB0 A9 A5			lda #<text
     8 1AB2 A0 1A			ldy #>text
     9 1AB4 20 3A 19			jsr print.print_text
    10 1AB7 68				pla
    11 1AB8 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   590 1ABB				print.m_print_word cursor.selected_entry.number
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1ABB AD 50 0E			lda CURSOR.SELECTED_ENTRY.NUMBER+1
     2 1ABE 20 63 19			jsr print.print_hex
     3 1AC1 AD 4F 0E			lda CURSOR.SELECTED_ENTRY.NUMBER
     4 1AC4 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   591 1AC7 E8				inx
   592 					
   593 1AC8 AD A2 1B			lda details_mode
   594 1ACB D0 4A			bne technical_details
   595
   596 				;===============================================================
   597
   598 1ACD				.proc readable_details
   599 1ACD				print.m_print_text "Genre:"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1ACD 4C D7 1A			jmp skip
     2 1AD0 47 65 6E 72 65 3A	text	.byte 'Genre:'
     3 1AD6 00				.byte 0
     4 1AD7			skip
     5 1AD7 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1ADA 48				pha
     7 1ADB A9 D0			lda #<text
     8 1ADD A0 1A			ldy #>text
     9 1ADF 20 3A 19			jsr print.print_text
    10 1AE2 68				pla
    11 1AE3 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   600
   601 1AE6				.proc copy_genre
   602 1AE6 AD 5B 0E			lda cursor.selected_entry.genre_number
   603 1AE9 0A				asl
   604 1AEA A8				tay
   605 1AEB B9 00 34 8D FA 1A + 	mwa genres_list,y genre_adr
   606 1AF7 A0 00			ldy #0
   607 1AF9			loop
   608 = 1AFA			genre_adr = *+1
   609 1AF9 B9 00 34			lda genres_list,y
   610 1AFC 9D 70 33			sta print.print_sm,x
   611 1AFF F0 09			beq exit
   612 1B01 C9 C0			cmp #$c0
   613 1B03 D0 01			sne
   614 1B05				jam
Macro: JAM [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 1B05 02				.byte $02
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   615 1B06 C8				iny
   616 1B07 E8				inx
   617 1B08 D0 EF			bne loop
   618 1B0A			exit
   619 					.endp
   620
   621 1B0A				.proc clear_genre
   622 1B0A A9 20			lda #' '
   623 1B0C E0 28		loop	cpx #screen_width
   624 1B0E F0 06			beq exit
   625 1B10 9D 70 33			sta print.print_sm,x
   626 1B13 E8				inx
   627 1B14 D0 F6			bne loop
   628 1B16			exit
   629 					.endp
   630
   631 1B16 60				rts
   632 					.endp
   633
   634 				;===============================================================
   635
   636 1B17				.proc technical_details
   637 1B17				print.m_print_text "Mode:"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B17 4C 20 1B			jmp skip
     2 1B1A 4D 6F 64 65 3A	text	.byte 'Mode:'
     3 1B1F 00				.byte 0
     4 1B20			skip
     5 1B20 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1B23 48				pha
     7 1B24 A9 1A			lda #<text
     8 1B26 A0 1B			ldy #>text
     9 1B28 20 3A 19			jsr print.print_text
    10 1B2B 68				pla
    11 1B2C 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   638 1B2F				print.m_print_byte cursor.selected_entry.the_cart_mode
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B2F AD 51 0E			lda CURSOR.SELECTED_ENTRY.THE_CART_MODE
     2 1B32 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   639 1B35				print.m_print_space
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_SPACE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B35 20 5C 19			jsr print.print_space
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   640 1B38				print.m_print_text "Bank:"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B38 4C 41 1B			jmp skip
     2 1B3B 42 61 6E 6B 3A	text	.byte 'Bank:'
     3 1B40 00				.byte 0
     4 1B41			skip
     5 1B41 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1B44 48				pha
     7 1B45 A9 3B			lda #<text
     8 1B47 A0 1B			ldy #>text
     9 1B49 20 3A 19			jsr print.print_text
    10 1B4C 68				pla
    11 1B4D 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   641 1B50				print.m_print_word cursor.selected_entry.start_bank_number
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B50 AD 53 0E			lda CURSOR.SELECTED_ENTRY.START_BANK_NUMBER+1
     2 1B53 20 63 19			jsr print.print_hex
     3 1B56 AD 52 0E			lda CURSOR.SELECTED_ENTRY.START_BANK_NUMBER
     4 1B59 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   642 1B5C				print.m_print_space
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_SPACE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B5C 20 5C 19			jsr print.print_space
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   643 1B5F A9 28 9D 70 33 E8		mva #'(' print.print_sm,x+
   644 1B65				print.m_print_byte cursor.selected_entry.initial_bank_number
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B65 AD 54 0E			lda CURSOR.SELECTED_ENTRY.INITIAL_BANK_NUMBER
     2 1B68 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   645 1B6B A9 29 9D 70 33 E8		mva #')' print.print_sm,x+
   646 1B71 20 5C 19			print.print_space
   647
   648 1B74 AD 58 0E			lda cursor.selected_entry.source_type
   649 1B77 D0 15			bne menu_entry_item
   650 1B79 A9 20			lda #' '
   651 1B7B 9D 70 33 E8			sta print.print_sm,x+
   652 1B7F 9D 70 33 E8			sta print.print_sm,x+
   653 1B83 9D 70 33 E8			sta print.print_sm,x+
   654 1B87 9D 70 33 E8			sta print.print_sm,x+
   655 1B8B 4C A0 1B			jmp no_menu_entry_item
   656 1B8E			menu_entry_item
   657 1B8E A9 28 9D 70 33 E8		mva #'(' print.print_sm,x+
   658 1B94				print.m_print_byte cursor.selected_entry.item_number
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_BYTE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1B94 AD 5A 0E			lda CURSOR.SELECTED_ENTRY.ITEM_NUMBER
     2 1B97 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   659 1B9A A9 29 9D 70 33 E8		mva #')' print.print_sm,x+
   660 1BA0			no_menu_entry_item	
   661 1BA0 60				rts
   662 					.endp			;End of technical_details
   663
   664 					.endp			;End of print_selected_entry
   665
   666 = 1BA1 00		HELP_MODE
   666 = 1BA2 00		DETAILS_MODE
   666 					.endp			;End of menu
   667
   668 				;===============================================================
   669
   670 1BA3				.proc result_status
   671
   672 = 0038			text_position = 56
   673
   674 1BA3				.proc print_searching
   675 1BA3 A2 38		 	ldx #text_position
   676 1BA5				print.m_print_text "Searching ....          "
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1BA5 4C C1 1B			jmp skip
     2 1BA8 53 65 61 72 63 68 + text	.byte 'Searching ....          '
     3 1BC0 00				.byte 0
     4 1BC1			skip
     5 1BC1 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1BC4 48				pha
     7 1BC5 A9 A8			lda #<text
     8 1BC7 A0 1B			ldy #>text
     9 1BC9 20 3A 19			jsr print.print_text
    10 1BCC 68				pla
    11 1BCD 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   677 1BD0 60				rts
   678 					.endp
   679
   680 1BD1				.proc print_search_finished_complete
   681 1BD1 A2 38			ldx #text_position
   682 1BD3				print.m_print_text "Search completed in "
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1BD3 4C EB 1B			jmp skip
     2 1BD6 53 65 61 72 63 68 + text	.byte 'Search completed in '
     3 1BEA 00				.byte 0
     4 1BEB			skip
     5 1BEB AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1BEE 48				pha
     7 1BEF A9 D6			lda #<text
     8 1BF1 A0 1B			ldy #>text
     9 1BF3 20 3A 19			jsr print.print_text
    10 1BF6 68				pla
    11 1BF7 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   683 1BFA				print.m_print_word search.search_frame_counter
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1BFA AD 71 0D			lda SEARCH.SEARCH_FRAME_COUNTER+1
     2 1BFD 20 63 19			jsr print.print_hex
     3 1C00 AD 70 0D			lda SEARCH.SEARCH_FRAME_COUNTER
     4 1C03 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   684 1C06 60				rts
   685 					.endp
   686
   687 1C07				.proc print_search_finished_incomplete
   688 1C07 A2 38			ldx #text_position
   689 1C09				print.m_print_text "Too many results in "
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1C09 4C 21 1C			jmp skip
     2 1C0C 54 6F 6F 20 6D 61 + text	.byte 'Too many results in '
     3 1C20 00				.byte 0
     4 1C21			skip
     5 1C21 AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1C24 48				pha
     7 1C25 A9 0C			lda #<text
     8 1C27 A0 1C			ldy #>text
     9 1C29 20 3A 19			jsr print.print_text
    10 1C2C 68				pla
    11 1C2D 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   690 1C30				print.m_print_word search.search_frame_counter
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1C30 AD 71 0D			lda SEARCH.SEARCH_FRAME_COUNTER+1
     2 1C33 20 63 19			jsr print.print_hex
     3 1C36 AD 70 0D			lda SEARCH.SEARCH_FRAME_COUNTER
     4 1C39 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   691 1C3C 60				rts
   692 					.endp
   693
   694 1C3D				.proc print_search_finished_user_break
   695 1C3D A2 38			ldx #text_position
   696 1C3F				print.m_print_text "User break.             "
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1C3F 4C 5B 1C			jmp skip
     2 1C42 55 73 65 72 20 62 + text	.byte 'User break.             '
     3 1C5A 00				.byte 0
     4 1C5B			skip
     5 1C5B AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1C5E 48				pha
     7 1C5F A9 42			lda #<text
     8 1C61 A0 1C			ldy #>text
     9 1C63 20 3A 19			jsr print.print_text
    10 1C66 68				pla
    11 1C67 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   697 1C6A 60				rts
   698 					.endp
   699
   700 				;===============================================================
   701
   702 1C6B				.proc print_found_entry_index	;Called during VBI
   703 1C6B A2 2E			ldx #46			
   704 1C6D A5 E4			lda result.found_entry_index
   705 1C6F 05 E5			ora result.found_entry_index+1
   706 1C71 D0 1A			bne print_found
   707 1C73				print.m_print_text "None"
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_TEXT [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1C73 4C 7B 1C			jmp skip
     2 1C76 4E 6F 6E 65		text	.byte 'None'
     3 1C7A 00				.byte 0
     4 1C7B			skip
     5 1C7B AD 47 19			lda print.print_text.text_adr	;Push for recursive call, low byte
     6 1C7E 48				pha
     7 1C7F A9 76			lda #<text
     8 1C81 A0 1C			ldy #>text
     9 1C83 20 3A 19			jsr print.print_text
    10 1C86 68				pla
    11 1C87 8D 47 19			sta print.print_text.text_adr	;Pull for recurive call, low byte
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   708 1C8A 4C 97 1C			jmp print_done
   709 1C8D			print_found
   710 1C8D				print.m_print_word result.found_entry_index
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1C8D A5 E5			lda RESULT.FOUND_ENTRY_INDEX+1
     2 1C8F 20 63 19			jsr print.print_hex
     3 1C92 A5 E4			lda RESULT.FOUND_ENTRY_INDEX
     4 1C94 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   711 1C97			print_done
   712
   713 1C97 A4 E3			ldy result.result_status
   714 1C99 C0 00			cpy #result.status.searching
   715 1C9B D0 1C			bne not_searching
   716 1C9D A5 14			lda cnt
   717 1C9F 4A				lsr
   718 1CA0 4A				lsr
   719 1CA1 29 03			and #3
   720 1CA3 A8				tay
   721 1CA4 B9 BF 1C			lda animation,y
   722 1CA7 9D 70 33			sta print.print_sm,x
   723 1CAA A2 42			ldx #66
   724 1CAC				print.m_print_word search.search_entry_index
Macro: EXTENDED_MENU.VISUALIZATION.PRINT.M_PRINT_WORD [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm]
     1 1CAC AD 6B 0D			lda SEARCH.SEARCH_ENTRY_INDEX+1
     2 1CAF 20 63 19			jsr print.print_hex
     3 1CB2 AD 6A 0D			lda SEARCH.SEARCH_ENTRY_INDEX
     4 1CB5 20 63 19			jsr print.print_hex
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Visualization.asm
   725 1CB8 60				rts
   726
   727 1CB9			not_searching
   728 1CB9 A9 2F			lda #'/'
   729 1CBB 9D 70 33			sta print.print_sm,x
   730 1CBE 60				rts
   731
   732 1CBF				.local animation
   733 1CBF 06 12 07 7C			.byte 6,18,7,124
   734 					.endl
   735
   736 					.endp			;End of print_found_entry_index
   737
   738 				;===============================================================
   739
   740 					.endp			;print_result_status
   741
   742 				;===============================================================
   743
   744 					.endp			;End of visualization
   800
   801 1CC3				icl "TheMenu-Starter.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Starter.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=CartMenu-Extended.asm
     5
     6 				;	When this procedure is called, the following conditions hold true
     7 				;	<I>     = $00
     8 				;	portb 	= $ff
     9 				;	basicf	= $01
    10 				;	ramtop  = $c0
    11 				;	ramsiz  = $c0
    12 				;	coldst  = $ff
    13
    14
    15 1CC3				.proc starter	
    16
    17 1CC3 AD 65 0D			lda search.search_status
    18 1CC6 C9 01			cmp #search.status.start_simple_menu
    19 1CC8 F0 27			beq start_simple_menu
    20 1CCA C9 02			cmp #search.status.start_selected_entry
    21 1CCC F0 29			beq start_selected_entry
    22 1CCE 4C CE 1C			jmp *
    23
    24 				;===============================================================
    25
    26 1CD1				.proc cold_start
    27 1CD1 78				sei				;Prevent VBI stage 2
    28 1CD2 A9 00 8D A2 D5		mva #0 the_cart.primary_bank_enable
    29 1CD7 AD 13 D0 8D FA 03		mva trig3 gintlk		;Make sure cartridge status is up to date
    30 1CDD 58				cli
    31 1CDE 4C 77 E4			jmp coldsv
    32 					.endp
    33
    34 1CE1				.proc activate_simple_menu	;Activate "simple menu" bank
    35 1CE1 78				sei				;Disable VBI stage 2
    36 1CE2 A2 00			ldx #<0
    37 1CE4 A0 00			ldy #>0
    38 1CE6 20 D6 07			jsr menu_core.set_bank
    39 1CE9 AD 13 D0 8D FA 03		mva trig3 gintlk
    40 1CEF 58				cli				;Enabled VBI stage 2
    41 1CF0 60				rts
    42 					.endp
    43
    44 				;===============================================================
    45
    46 1CF1				.proc start_simple_menu
    47 1CF1 20 E1 1C			jsr activate_simple_menu
    48 1CF4 4C 00 A0			jmp cartmenu.entry_cartmenu
    49 					.endp
    50
    51 				;===============================================================
    52
    53 1CF7				.proc start_selected_entry	;Start selected entry
    54
    55 1CF7 AD 51 0E			lda cursor.selected_entry.the_cart_mode
    56 1CFA C9 E2			cmp #the_cart_mode.tc_mode_atr_file
    57 1CFC D0 03 4C 3A 1E		jeq atr_starter.start_atr_entry ;ATRs get their own handling
    58
    59 1D01 A9 00			lda #0				;Initialize boot and RESET relevant state
    60 1D03 85 08			sta warmst
    61 1D05 8D 44 02			sta coldst
    62 1D08 85 09			sta boot?
    63
    64 1D0A 20 E1 1C			jsr activate_simple_menu	;All following parts require the simple menu
    65
    66 				;	Add initial bank offset
    67 1D0D 18 AD 52 0E 6D 54 + 	adw cursor.selected_entry.start_bank_number cursor.selected_entry.initial_bank_number
    68
    69 1D20 20 28 1D			jsr check_start_entry_item
    70 1D23 90 1F			jcc rom_starter.start_rom_entry
    71 1D25 4C 53 1D			jmp rom_starter.start_rom_entry_item
    72
    73 				;===============================================================
    74
    75 1D28				.proc check_start_entry_item	;Determine source and menu version of selected entry, OUT: <C>=0 to start the entry, <C>=1 to start the entry item
    76
    77 1D28 AD 58 0E			lda cursor.selected_entry.source_type
    78 1D2B C9 01			cmp #menu_entry_source_type.menu_entry_item
    79 1D2D D0 13			bne entry			;Not an item that can be started but a regular entry
    80
    81 1D2F AD 59 0E			lda cursor.selected_entry.item_menu_version
    82 1D32 F0 0E			beq entry			;Not a supported version for direct start.
    83
    84 1D34 AD 0F D2			lda skctl			;If any key with CONTROL is pressed, start the menu, not the item
    85 1D37 29 04			and #4				;Bit 2 = 0 indicates last key is still pressed
    86 1D39 D0 05			bne entry_item			;No key pressed
    87 1D3B AD 09 D2			lda kbcode			;Bit 7 = 1 set means CONTROL pressed
    88 1D3E 30 02			bmi entry
    89
    90 1D40			entry_item
    91 1D40 38				sec
    92 1D41 60				rts
    93
    94 1D42 18			entry	clc
    95 1D43 60				rts
    96 					.endp
    97
    98 				;;===============================================================
    99
   100 					.macro m_clear_main_ram_and_zp	;Clear all the RAM starting at page <A>, assume screen DMA is off
   101 					sta clear+2
   102 					eor #$ff
   103 					clc
   104 					adc #>$a000
   105 					tay
   106 					lda #0
   107 					tax
   108 				clear	sta $ff00,x
   109 					inx
   110 					bne clear
   111 					inc clear+2
   112 					dey
   113 					bne clear
   114 				clear_zp				;Clear user ZP $80-$ff
   115 					sta $80,x
   116 					inx
   117 					bpl clear_zp
   118 					.endm
   119
   120 				;===============================================================
   121
   122 1D44				icl "rom/TheMenu-ROM-Starter.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\rom\TheMenu-ROM-Starter.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=../CartMenu-Extended.asm
     5
     6 1D44				.proc rom_starter
     7
     8 1D44				.proc start_rom_entry		;Start selected entry, The!Cart is ON
     9 1D44 20 30 1E			jsr check_lock
    10 1D47 AD 51 0E			lda cursor.selected_entry.the_cart_mode
    11 1D4A AE 52 0E			ldx cursor.selected_entry.start_bank_number
    12 1D4D AC 53 0E			ldy cursor.selected_entry.start_bank_number+1
    13 1D50 4C 03 A0			jmp cartmenu.entry_runcart	;Start cartridge
    14 					.endp
    15
    16 				;===============================================================
    17
    18 1D53				.proc start_rom_entry_item	;Start item of selected entry, The!Cart is ON
    19
    20 = 0100			starter_ram = $100
    21
    22 1D53 20 6D 1D			jsr copy_starter
    23
    24 1D56 A9 00 85 E0 A9 01 + 	mwa #starter_ram cartmenu.runadr ;Set callback run address
    25
    26 1D5E 20 30 1E			jsr check_lock
    27 1D61 AD 51 0E			lda cursor.selected_entry.the_cart_mode
    28 1D64 AE 52 0E			ldx cursor.selected_entry.start_bank_number
    29 1D67 AC 53 0E			ldy cursor.selected_entry.start_bank_number+1
    30 1D6A 4C 12 A0			jmp cartmenu.entry_runcart_adr	;Start cartridge via run address
    31
    32 				;===============================================================
    33
    34 1D6D				.proc copy_starter		;Copy entry start routine to low RAM
    35 1D6D A0 00			ldy #0
    36 1D6F B9 85 1D		loop	lda starter_template,y
    37 1D72 99 00 01			sta starter_ram,y
    38 1D75 C8				iny
    39 1D76 C0 AB			cpy #.len starter
    40 1D78 D0 F5			bne loop
    41 1D7A AD 59 0E 85 00		mva cursor.selected_entry.item_menu_version starter.item_menu_version
    42 1D7F AD 5A 0E 85 01		mva cursor.selected_entry.item_number starter.item_number
    43 1D84 60				rts
    44 					.endp
    45
    46 				;===============================================================
    47
    48 1D85			starter_template			;Start address of template
    49 1D85				.proc starter,starter_ram
    50 = 0000				item_menu_version = $00
    51 = 0001				item_number = $01
    52
    53 0100 A9 04			lda #>($0400)
    54 0102				m_clear_main_ram_and_zp
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.M_CLEAR_MAIN_RAM_AND_ZP [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Starter.asm]
     1 0102 8D 10 01			sta clear+2
     2 0105 49 FF			eor #$ff
     3 0107 18				clc
     4 0108 69 A0			adc #>$a000
     5 010A A8				tay
     6 010B A9 00			lda #0
     7 010D AA				tax
     8 010E 9D 00 FF		clear	sta $ff00,x
     9 0111 E8				inx
    10 0112 D0 FA			bne clear
    11 0114 EE 10 01			inc clear+2
    12 0117 88				dey
    13 0118 D0 F4			bne clear
    14 011A			clear_zp				;Clear user ZP $80-$ff
    15 011A 95 80			sta $80,x
    16 011C E8				inx
    17 011D 10 FB			bpl clear_zp
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\rom\TheMenu-ROM-Starter.asm
    55
    56 011F 20 9C 01			jsr open_editor
    57
    58 0122 A5 14			lda $14
    59 0124			wait_vbi
    60 0124 C5 14			cmp $14
    61 0126 F0 FC			beq wait_vbi
    62
    63 0128 A5 00			lda item_menu_version
    64 012A C9 01			cmp #1
    65 012C F0 09			beq atarimax.old
    66 012E C9 02			cmp #2
    67 0130 F0 39			beq atarimax.new
    68 0132 C9 03			cmp #3
    69 0134 F0 42			beq megacart
    70 0136				jam
Macro: JAM [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 0136 02				.byte $02
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\rom\TheMenu-ROM-Starter.asm
    71
    72 				;===============================================================
    73
    74 0137				.proc atarimax
    75 					
    76 0137				.proc old
    77 0137 A2 20			ldx #$20
    78 0139 A0 00			ldy #0
    79 013B			loop
    80 013B B9 00 A0		source	lda $a000,y
    81 013E 99 00 20		target	sta $2000,y
    82 0141 C8				iny
    83 0142 D0 F7			bne loop
    84 0144 EE 3D 01			inc source+2
    85 0147 EE 40 01			inc target+2
    86 014A CA				dex
    87 014B D0 EE			bne loop
    88 014D 8E BD 34			stx $34bd			;Black screen
    89 0150 A9 5D 8D 27 31 A9 + 	mwa #callback $3127		;Turn "JSR get_stick_l2f7b" into "JSR callback"
    90 015A 4C 15 31			jmp $3115
    91
    92 015D			callback				;Simulate sequence of cursor down
    93 015D A5 01			lda item_number
    94 015F F0 08			beq start
    95 0161 20 63 35			jsr $3563			;Cursor down
    96 0164 C6 01			dec item_number
    97 0166 4C 5D 01			jmp callback
    98 0169 38			start	sec				;C=1 indicates start
    99 016A 60				rts
   100 					.endp
   101
   102 				;===============================================================
   103
   104 016B				.proc new
   105 = A445			the_cart_start_address =$a445		;IN: <A>=entry number (1..127), this is the same entry point that is used by the autostart feature of the AtariMax itself.
   106
   107 016B A9 00 8D 00 D5		mva #0 $d500			;Activate bank 0 of the AtariMax cart manually because we do not go through the boot vector
   108 0170 A5 01			lda item_number
   109 0172 18				clc
   110 0173 69 01			adc #1				;Convert base 0 to base 1
   111 0175 4C 45 A4			jmp the_cart_start_address
   112 					.endp
   113
   114 				;===============================================================
   115
   116 					.endp				;End of Atarimax
   117
   118 				;===============================================================
   119
   120 0178				.proc megacart
   121 0178 A9 00			lda #0				;Activate bank 0 of the MegaCart 512k, 2MB cart manually because we do not go through the boot vector.
   122 017A 8D 00 D5			sta $d500			;MegaCart 4MB would have start bank 254, but that's not supported anyway.
   123 017D A5 01			lda item_number
   124 017F 48				pha
   125 0180 4A				lsr
   126 0181 4A				lsr
   127 0182 4A				lsr
   128 0183 4A				lsr
   129 0184 8D 21 7C			sta $7c21			;Item number DIV 16
   130 0187 68				pla
   131 0188 29 0F			and #15
   132 018A 8D 20 7C			sta $7c20			;Item number MOD 16
   133 018D AD 00 02 8D 25 7C + 	mwa vdslst $7c25		;Preset "old" DLI vector
   134 0199 4C F3 B7			jmp $b7f3
   135 					.endp
   136
   137 019C				.proc open_editor
   138 019C A9 40 8D 0E D4		mva #$40 nmien
   139 01A1 58				cli
   140 01A2 AD 01 E4			lda $e401			;Open E:
   141 01A5 48				pha
   142 01A6 AD 00 E4			lda $e400
   143 01A9 48				pha
   144 01AA 60				rts
   145 					.endp
   146
   147 					.endp				;End of starter
   148 					
   149 					.endp				;End of start_rom_entry_item
   150
   151 1E30				.proc check_lock		;Check of The!Cart register should be locked, OUT: <C>=1 to lock, <C>=0 to keep unlocked
   152 1E30 38				sec				;Default, lock The!Cart registers
   153 1E31 AD 0F D2			lda skstat			;If SHIFT is pressed, don't lock the The!Cart configuration
   154 1E34 29 08			and #8				;Bit 3 = 0 means SHIFT is pressed
   155 1E36 D0 01			bne not_pressed			;Skip next if not 0
   156 1E38 18				clc				;Don't lock The!Cart registers
   157 1E39			not_pressed
   158 1E39 60				rts
   159 					.endp
   160
   161 					.endp				;End of rom_starter
   123
   124 				;===============================================================
   125
   126 1E3A				icl "atr/TheMenu-ATR-Starter.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
     1
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=../CartMenu-Extended.asm
     5
     6
     7 1E3A				.proc atr_starter	;The!Cart is OFF
     8
     9 1E3A				.enum atr_header	;Offset in the ATR header
    10
    11 = 0004				sector_size = 4		;Word
    12
    13 = 0002				paragraph_0 = 2		;Byte 1 of 4
    14 = 0003				paragraph_1 = 3		;Byte 2 of 4
    15 = 0006				paragraph_2 = 6		;Byte 3 of 4
    16 = 0007				paragraph_3 = 7		;Byte 4 of 4
    17
    18 = 1680				sd_paragraphs = $1680	;Value of paragraph_0/1/2/3 for single sided single desity disk with 720 sectors
    19 					.ende
    20
    21 1E3A				.enum sector_size
    22 = 0080				sd	= $80
    23 = 0100				dd	= $100
    24 					.ende
    25
    26 1E3A				icl "TheMenu-ATR-Starter-Globals.asm"
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter-Globals.asm
     1 				;
     2 				;	>>>  The!Cart - ExtendedMenu by JAC! <<<
     3 				;
     4 				;	@com.wudsn.ide.asm.mainsourcefile=../CartMenu-Extended.asm
     5 				;
     6 				;	The definition in this file are used by both the RAM and the ROM part of the ATR started.
     7 				;	Only zero page locations used by DISKIN/SIOV must be used.
     8 				;	Using zero page locations usde by CIO will break DOS like access.
     9
    10 = 0000			selected_item_number	= $00	;Byte, used in patched ATR file menus, see AtrLoader.java
    11 = 0004			bootini    		= $04	;Word, same as in OS boot process
    12 = 000C			dosini	   		= $0c	;Word, same as in OS boot process
    13 = 0015			buffer_ptr		= $15	;Word, BUFADR, normally used by DSKINV
    14 = 0032			cart_start_bank		= $32	;Word, BFENLO, normally used by SIOV
    15 = 0034			cart_bank  		= $34	;Word, BFENLO, normally used by SIOV
    16 = 0036			cart_ptr  		= $36	;Word, LTEMP, normally used by SIOV
    17 = 0038			buffer_len		= $38	;Byte, BUFRFL, normally used by SIOV
    18 = 0039			empty_dl   		= $39	;3 bytes, RECVDN/XMTDON/CHKSNT, normally used by SIOV
    19 = 0043			fmszpg			= $43	;6 bytes reserved for the File Managing System (FMS)
    20 = 0700			boot_buffer 		= $700
    27
    28 = 0043			starter_ptr		= fmszpg	;Used during initialization only, make sure it is not in the user ZP $80-$ff
    29 = 0045			jsr_ptr			= fmszpg+2	;Used during initialization only
    30
    31 1E3A			start_atr_entry
    32 1E3A AD 5A 0E 85 00		mva cursor.selected_entry.item_number selected_item_number
    33 1E3F 20 67 1E			jsr copy_starter
    34 1E42 A9 20			lda #>(starter_template+$ff)	;Clear everything starting at the relocatable parts
    35 1E44				m_clear_main_ram_and_zp
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.M_CLEAR_MAIN_RAM_AND_ZP [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu-Starter.asm]
     1 1E44 8D 52 1E			sta clear+2
     2 1E47 49 FF			eor #$ff
     3 1E49 18				clc
     4 1E4A 69 A0			adc #>$a000
     5 1E4C A8				tay
     6 1E4D A9 00			lda #0
     7 1E4F AA				tax
     8 1E50 9D 00 FF		clear	sta $ff00,x
     9 1E53 E8				inx
    10 1E54 D0 FA			bne clear
    11 1E56 EE 52 1E			inc clear+2
    12 1E59 88				dey
    13 1E5A D0 F4			bne clear
    14 1E5C			clear_zp				;Clear user ZP $80-$ff
    15 1E5C 95 80			sta $80,x
    16 1E5E E8				inx
    17 1E5F 10 FB			bpl clear_zp
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    36 1E61 20 89 1F			jsr prepare_boot
    37 1E64 6C 43 00			jmp (starter_ptr)		;Jump to jump_boot
    38
    39 				;===============================================================
    40
    41 1E67				.proc copy_starter		;Copy start routine to low RAM, OUT: <p1>=loader_base_address
    42
    43 				;	Relocate JSR calls in to JSR JUMP_...
    44 					.macro m_reloc jsr_label jump_label
    45 					adw starter_ptr #(:jump_label-starter) jsr_ptr
    46 				 
    47 				 	ldy #:jsr_label+1-starter
    48 					mva jsr_ptr (starter_ptr),y
    49 					iny
    50 					mva jsr_ptr+1 (starter_ptr),y
    51 					.endm
    52
    53 1E67 AD 56 0E 85 43 AD + 	mwa cursor.selected_entry.loader_base_address starter_ptr
    54
    55 1E71 A0 00			ldy #0
    56 1E73 B9 F3 1F		loop	lda starter,y		
    57 1E76 91 43			sta (starter_ptr),y
    58 1E78 C8				iny
    59 1E79 C0 E7			cpy #.len starter
    60 1E7B D0 F6			bne loop
    61
    62 				;	Compute disk status value based on ATR size and sector size
    63 1E7D 20 1F 1F			jsr set_disk_status_code
    64
    65 				;	Copy start bank into starter
    66 1E80 A0 45			ldy #starter.simulate_siov.start_bank_number_lo-starter
    67 1E82 AD 52 0E 91 43		mva cursor.selected_entry.start_bank_number (starter_ptr),y
    68 1E87 A0 47			ldy #starter.simulate_siov.start_bank_number_hi-starter
    69 1E89 AD 53 0E 91 43		mva cursor.selected_entry.start_bank_number+1 (starter_ptr),y
    70
    71 				;	Relocate jump table in starter
    72 1E8E				m_reloc starter.jmp_boot   starter.simulate_boot
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1E8E 18 A5 43 69 93 85 + 	adw starter_ptr #(STARTER.SIMULATE_BOOT-starter) jsr_ptr
     3 1E9B A0 01		 	ldy #STARTER.JMP_BOOT+1-starter
     4 1E9D A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1EA1 C8				iny
     6 1EA2 A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    73 1EA6				m_reloc starter.jmp_dskinv starter.simulate_dskinv
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1EA6 18 A5 43 69 09 85 + 	adw starter_ptr #(STARTER.SIMULATE_DSKINV-starter) jsr_ptr
     3 1EB3 A0 04		 	ldy #STARTER.JMP_DSKINV+1-starter
     4 1EB5 A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1EB9 C8				iny
     6 1EBA A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    74 1EBE				m_reloc starter.jmp_siov   starter.simulate_siov
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1EBE 18 A5 43 69 13 85 + 	adw starter_ptr #(STARTER.SIMULATE_SIOV-starter) jsr_ptr
     3 1ECB A0 07		 	ldy #STARTER.JMP_SIOV+1-starter
     4 1ECD A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1ED1 C8				iny
     6 1ED2 A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    75
    76 				;	Relocate initialization calls in simulate_boot
    77 1ED6				m_reloc starter.simulate_boot.jsr_bootini starter.simulate_boot.jump_bootini
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1ED6 18 A5 43 69 E1 85 + 	adw starter_ptr #(STARTER.SIMULATE_BOOT.JUMP_BOOTINI-starter) jsr_ptr
     3 1EE3 A0 CE		 	ldy #STARTER.SIMULATE_BOOT.JSR_BOOTINI+1-starter
     4 1EE5 A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1EE9 C8				iny
     6 1EEA A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    78 1EEE				m_reloc starter.simulate_boot.jsr_dosini  starter.simulate_boot.jump_dosini
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1EEE 18 A5 43 69 E4 85 + 	adw starter_ptr #(STARTER.SIMULATE_BOOT.JUMP_DOSINI-starter) jsr_ptr
     3 1EFB A0 D1		 	ldy #STARTER.SIMULATE_BOOT.JSR_DOSINI+1-starter
     4 1EFD A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1F01 C8				iny
     6 1F02 A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    79
    80 				;	Relocate JSR SIOV calls in simulate_boot to JSR JMP_SIOV
    81 				;	Make sure this is the last relocation, because the starter uses jump (jsr_ptr) for SIOV
    82 1F06				m_reloc starter.simulate_boot.jsr_siov starter.jmp_siov
Macro: EXTENDED_MENU.STARTER.START_SELECTED_ENTRY.ATR_STARTER.COPY_STARTER.M_RELOC [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm]
     1 1F06 18 A5 43 69 06 85 + 	adw starter_ptr #(STARTER.JMP_SIOV-starter) jsr_ptr
     3 1F13 A0 AB		 	ldy #STARTER.SIMULATE_BOOT.JSR_SIOV+1-starter
     4 1F15 A5 45 91 43			mva jsr_ptr (starter_ptr),y
     5 1F19 C8				iny
     6 1F1A A5 46 91 43			mva jsr_ptr+1 (starter_ptr),y
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
    83 1F1E 60				rts
    84
    85 				;===============================================================
    86 				;	Compute disk status value based on ATR size and sector size.
    87 				;	The ATR header is contained in the first 16 bytes of the first bak of the ATR entry.
    88 				;	Any software that really cares about supporting big disks is going to be using PERCOM block commands.
    89 				;	So the best model for DVSTAT is to follow here is the XF551.
    90 				;	Short disks are handled as if they were the next largest full disk.
    91 				;	- SS/SD: %000xxxxx for 128 byte/sec <= 720 sectors
    92 				;	- SS/ED: %100xxxxx for 128 byte/sec >  720 sectors
    93 				;	- SS/DD: %001xxxxx for 256 byte/sec <= 720 sectors
    94 				;	- DS/DD: %011xxxxx for 256 byte/sec >  720 sectors
    95
    96 1F1F				.proc set_disk_status_code
    97
    98 = 0086				sector_size_mode = x1
    99 = 0087				disk_size_mode = x2
   100
   101 1F1F 78				sei
   102 1F20 A9 20 8D A6 D5		mva #the_cart_mode.tc_mode_flexi the_cart.mode
   103 				;	sta the_cart.configuration_lock		TODO: Mail sent to hias
   104 1F25 AE 52 0E			ldx cursor.selected_entry.start_bank_number
   105 1F28 AC 53 0E			ldy cursor.selected_entry.start_bank_number+1 
   106 1F2B 20 D6 07			jsr menu_core.set_bank
   107
   108 				;	Check the sector size.
   109 1F2E A9 00 85 86			mva #$00 sector_size_mode
   110 1F32 AD 05 A0 C9 00 D0 + 	cpw module_a000+atr_header.sector_size #sector_size.sd
   111 1F3E F0 15			beq is_sd
   112 1F40 AD 05 A0 C9 01 D0 + 	cpw module_a000+atr_header.sector_size #sector_size.dd
   113 1F4C F0 03			beq is_dd
   114 1F4E 4C 77 E4			jmp coldsv
   115 1F51 A9 02 85 86		is_dd	mva #$02 sector_size_mode
   116 1F55			is_sd
   117
   118 				;	Check the disk size.
   119 1F55 A9 01 85 87			mva #$01 disk_size_mode		;Assume >720
   120 1F59 AD 06 A0			lda module_a000+atr_header.paragraph_2
   121 1F5C 0D 07 A0			ora module_a000+atr_header.paragraph_3
   122 1F5F D0 11			bne is_large
   123 1F61 38				sec
   124 1F62 AD 02 A0			lda module_a000+atr_header.paragraph_0
   125 1F65 E9 80			sbc #<atr_header.sd_paragraphs
   126 1F67 AD 03 A0			lda module_a000+atr_header.paragraph_1
   127 1F6A E9 16			sbc #>atr_header.sd_paragraphs
   128 1F6C B0 04			bcs is_large
   129 1F6E A9 00 85 87			mva #$00 disk_size_mode		;Is actually <=720
   130 1F72			is_large
   131 1F72 A5 86			lda sector_size_mode
   132 1F74 05 87			ora disk_size_mode
   133 1F76 AA				tax
   134 1F77 BD 85 1F			lda dvstat_table,x 
   135 1F7A A0 43			ldy #starter.simulate_siov.disk_status_code-starter
   136 1F7C 91 43			sta (starter_ptr),y
   137 1F7E A9 00 8D A2 D5		mva #0 the_cart.primary_bank_enable
   138 1F83 58				cli
   139 1F84 60				rts
   140 					
   141 1F85				.local dvstat_table
   142 1F85 00				.byte %00000000 ;for 128 byte/sec <= 720 sectors
   143 1F86 80				.byte %10000000 ;for 128 byte/sec >  720 sectors
   144 1F87 20				.byte %00100000 ;for 256 byte/sec <= 720 sectors
   145 1F88 60				.byte %01100000 ;for 256 byte/sec >  720 sectors
   146 					.endl
   147
   148 					.endp				;End of set_disk_status
   149
   150 					.endp				;End of copy_starter
   151
   152 				;===============================================================
   153
   154 1F89				.proc prepare_boot		;Setup boot parameters and vectors
   155 					
   156 1F89 A9 31 8D 00 03		mva #$31 ddevic
   157 1F8E A9 01 8D 01 03		mva #1   dunit			;Unit 1
   158 1F93 A9 52 8D 02 03		mva #'R' dcomnd
   159 1F98 A9 1F 8D 06 03		mva #31  dtimlo
   160 1F9D A9 01 8D 0A 03 A9 + 	mwa #1   daux1			;First sector number
   161 1FA7 A9 00 8D 04 03 A9 + 	mwa #boot_buffer dbuflo
   162 1FB1 A9 80 8D 08 03 A9 + 	mwa #sector_size.sd dbytlo
   163 1FBB 20 F0 1F			jsr jmp_siov_ptr		;Load first sector
   164
   165 1FBE AD 01 07 8D 41 02		mva boot_buffer+1 dbsect	;Use sector count from boot header
   166
   167 1FC4 AD 02 07			lda boot_buffer+2 		;Use load address from boot header
   168 1FC7 8D 42 02			sta bootad
   169 1FCA 8D 04 03			sta dbuflo
   170 1FCD AD 03 07			lda boot_buffer+3 
   171 1FD0 8D 43 02			sta bootad+1
   172 1FD3 8D 05 03			sta dbuflo+1
   173 					
   174 1FD6 AD 04 07 85 0C AD + 	mwa boot_buffer+4 dosini	;Use DOSINI address from boot header
   175
   176 1FE0 18 AD 42 02 69 06 + 	adw bootad #6 bootini		;Preprepare initialization jump
   177 1FEF 60				rts
   178
   179 1FF0				.proc jmp_siov_ptr		;JSR wrapper procedure
   180 1FF0 6C 45 00			jmp (jsr_ptr)
   181 					.endp
   182
   183 					.endp
   184
   185 				;===============================================================
   186
   187 1FF3			starter_template
   188 1FF3				.proc starter			;Starter RAM part, Must be relocatable
   189
   190 1FF3			jmp_boot				;Fixed start address offset +0
   191 1FF3 4C 86 20			jmp simulate_boot
   192 1FF6			jmp_dskinv				;Fixed start address offset +3
   193 1FF6 4C FC 1F			jmp simulate_dskinv
   194 1FF9			jmp_siov				;Fixed start address offset +6
   195 1FF9 4C 06 20			jmp simulate_siov
   196
   197 				;===============================================================
   198 				;
   199 				;	Sector offsets overview
   200 				;
   201 				;	Offset	SD	DD
   202 				;	$000	HEADER	HEADER
   203 				;	$080	1	1
   204 				;	$100	2	2
   205 				;	$180	3	3
   206 				;	$200	4	4
   207 				;	$280	5
   208 				;	$300	6	5
   209 				;	$380	7
   210 				;	$400	8	6
   211
   212 1FFC				.proc simulate_dskinv		;Minimum setup only
   213 1FFC A9 31			lda #$31
   214 1FFE 8D 00 03			sta ddevic
   215 2001 A9 01			lda #1
   216 2003 8D 01 03			sta dunit
   217 					.endp				;Fall through
   218
   219 				;===============================================================
   220
   221 2006				.proc simulate_siov
   222 2006 AD 00 03			lda ddevic			;Is device "Dx:"?
   223 2009 C9 31			cmp #$31
   224 200B F0 03 4C 59 E4		jne siov			;No, resort to normal SIO, should never be the case...
   225
   226 2010 78				sei				;Disable TRIG3 check for setting The!Cart registers and shadow register copying
   227
   228 2011				.proc disable_screen		;Create empty DL and set hardware pointers to it.
   229 2011 AD 31 02			lda sdlsth
   230 2014 C9 A0			cmp #>module_a000
   231 2016 90 15			bcc dl_not_in_module		;Do not disable the screen, if the DL is not in the module area.
   232
   233 2018 A9 41			lda #$41			;Create empty DL in zero page
   234 201A A2 39			ldx #<empty_dl
   235 201C A0 00			ldy #>empty_dl
   236 201E 85 39			sta empty_dl
   237 2020 86 3A			stx empty_dl+1
   238 2022 84 3B			sty empty_dl+2
   239
   240 2024 8D 0A D4			sta wsync			;Change ANTIC pointer at the begin of the next scanline and before the module is enabled
   241 2027 8E 02 D4			stx dlptr
   242 202A 8C 03 D4			sty dlptr+1
   243
   244 202D			dl_not_in_module
   245 					.endp				;End of disable_screen
   246
   247 				;===============================================================
   248
   249 202D A9 00			lda #$00			;The ROM part of the starter is in bank 0 at menu_atr_rom
   250 202F 8D A0 D5			sta the_cart.primary_bank_lo	;Set primary bank register low byte (0-255, default: 0), also enables the cart (!)
   251 2032 8D A1 D5			sta the_cart.primary_bank_hi	;Set primary bank register high byte (0-63, default: 0), also enables the cart (!)
   252
   253 = 2036			disk_status_code = *+1
   254 2035 A9 20			lda #$20			;Set during initialization based on ATR header
   255 = 2038			start_bank_number_lo = *+1		;Set during initialization based on menu entry
   256 2037 A2 FF			ldx #$ff
   257 = 203A			start_bank_number_hi =*+1		;Set during initialization based on menu entry
   258 2039 A0 FF			ldy #$ff
   259 203B 20 00 B8			jsr start_atr_file_rom.special_sio 	;Call the ROM part of the starter routine
   260 203E A9 00 8D A2 D5		mva #0 the_cart.primary_bank_enable	;Disable The!Cart again, so it is off in case we just return 
   261 2043 B0 3A			bcs return_with_status			;If <C>=1, then <Y>=SIO status code to be returned
   262 					
   263 2045 A5 34 8D A0 D5		mva cart_bank the_cart.primary_bank_lo		;Set primary bank register low byte (0-255, default: 0), also enables the cart (!)
   264 204A A5 35 8D A1 D5		mva cart_bank+1 the_cart.primary_bank_hi	;Set primary bank register high byte (0-63, default: 0), also enables the cart (!)
   265
   266 				;===============================================================
   267
   268 204F				.proc copy_sector
   269
   270 204F A0 00			ldy #0				;Index counter
   271 2051 A2 00			ldx #0				;Constant zero to disable the The!Cart
   272 2053 A5 16			lda buffer_ptr+1		;Will the buffer and the ROM overlap potentially?
   273 2055 C9 9F			cmp #>[module_a000-$100]	;Must consider the last page especially
   274 2057 B0 13			bcs switch_per_byte		;Yes, so switch per byte
   275 					
   276 2059				.proc switch_per_sector
   277 2059 A9 01			lda #1
   278 205B 8D A2 D5			sta the_cart.primary_bank_enable;Enable The!Cart
   279
   280 205E B1 36		loop	lda (cart_ptr),y
   281 2060 91 15			sta (buffer_ptr),y
   282 2062 C8				iny
   283 2063 C4 38			cpy buffer_len			;Compare with length in ZP
   284 2065 D0 F7			bne loop
   285 2067 8E A2 D5			stx the_cart.primary_bank_enable;Disable The!Cart
   286 206A F0 11			beq done			;<Z>=1
   287 					.endp
   288
   289 206C				.proc switch_per_byte
   290 206C A9 01		loop	lda #1
   291 206E 8D A2 D5			sta the_cart.primary_bank_enable;Enable The!Cart
   292 2071 B1 36			lda (cart_ptr),y
   293 2073 8E A2 D5			stx the_cart.primary_bank_enable;Disable The!Cart
   294 2076 91 15			sta (buffer_ptr),y
   295 2078 C8				iny
   296 2079 C4 38			cpy buffer_len			;Compare with length in ZP
   297 207B D0 EF			bne loop
   298 					.endp
   299 207D			done
   300 					.endp
   301
   302 				;===============================================================
   303
   304 207D A0 01			ldy #1				;Return with DSTATS=1, <Y>=1; <Z>=1; <N>=0
   305 207F			return_with_status
   306 207F 8C 03 03			sty dstats
   307 2082 C0 01			cpy #1
   308 2084 58				cli				;Enable VBI stage 2 again
   309 2085 60				rts
   310 					.endp				;End of simulate_sio
   311
   312 				;===============================================================
   313 				;	The boot simulation is located as last part of the starter, so it can be overwritten after the boot process.
   314 				;	This increases the compatibility because only real SIO parts have to remain resident.
   315
   316 2086				.proc simulate_boot		;Must be called immediately after VBI.
   317 = 0A00				ram_start = $0a00
   318
   319 2086				.proc clear_ram			;Clear RAM up to the DL
   320 2086 A9 0A 85 16			mva #>ram_start buffer_ptr+1
   321 208A A9 00			lda #0
   322 208C 85 15			sta buffer_ptr
   323 208E A8				tay
   324 208F 91 15		loop	sta (buffer_ptr),y
   325 2091 C8				iny
   326 2092 D0 FB			bne loop
   327 2094 E6 16			inc buffer_ptr+1
   328 2096 A6 16			ldx buffer_ptr+1		;Page of DL reached?
   329 2098 EC 31 02			cpx sdlsth
   330 209B D0 F2			bne loop
   331 					.endp
   332
   333 209D			sector_loop
   334
   335 209D			jsr_siov
   336 209D 20 F9 1F			jsr jmp_siov			;Must be relocated
   337 20A0 18 AD 04 03 6D 08 + 	adw dbuflo dbytlo
   338 20B3 EE 0A 03 D0 03 EE + 	inw daux1
   339 20BB CE 41 02			dec dbsect
   340 20BE D0 DD			bne sector_loop
   341
   342 20C0			jsr_bootini
   343 20C0 20 D4 20			jsr jump_bootini		;Must be relocated
   344 20C3			jsr_dosini
   345 20C3 20 D7 20			jsr jump_dosini			;Must be relocated
   346 20C6 A5 09			lda boot?			;Set bit 0 to indicate DOSINI is set
   347 20C8 09 01			ora #1
   348 20CA 85 09			sta boot?
   349 20CC A9 00 8D 44 02		mva #0 coldst
   350 20D1 4C 74 E4			jmp warmsv
   351
   352 20D4				.proc jump_bootini		;JSR wrapper procedure
   353 20D4 6C 04 00			jmp (bootini)
   354 					.endp
   355
   356 20D7				.proc jump_dosini		;JSR wrapper procedure
   357 20D7 6C 0C 00			jmp (dosini)
   358 					.endp
   359
   360 					.endp				;End of simulate_boot
   361
   362 					.endp				;End of starter
   363
   364 20DA				m_info atr_starter.starter
Macro: M_INFO [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 					.print "ATR_STARTER.STARTER: " , ATR_STARTER.STARTER, " - ", ATR_STARTER.STARTER + .len ATR_STARTER.STARTER -1, " (", .len ATR_STARTER.STARTER,")"
     1 				ATR_STARTER.STARTER: $1FF3 - $20D9 ($00E7)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\atr\TheMenu-ATR-Starter.asm
   365 					.echo "Critical SIO simulation section has  ", [starter.simulate_boot-starter]+1, " bytes."
   365 				Critical SIO simulation section has  $0094 bytes.
   366
   367 					.endp				;End of atr_starter
   127
   128 					.endp				;End of start_selected_entry
   129
   130 					.endp				;End of starter
   802
   803 				;===============================================================
   804 20DA			end_of_code
   805
   806 20DA				m_assert_end_of_code data_start
Macro: M_ASSERT_END_OF_CODE [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 20DA			end_of_code
     5 					.print "END_OF_CODE (",end_of_code,") <= DATA_START (",DATA_START,"), ", DATA_START-end_of_code, " bytes free" 
     5 				END_OF_CODE ($20DA) <= DATA_START ($2400), $0326 bytes free
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\TheMenu.asm
   807
   808 					.endp				;End of extended_menu
   367
   368 20DA				m_info extended_menu
Macro: M_INFO [Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Kernel-Equates.asm]
     1 					.print "EXTENDED_MENU: " , EXTENDED_MENU, " - ", EXTENDED_MENU + .len EXTENDED_MENU -1, " (", .len EXTENDED_MENU,")"
     1 				EXTENDED_MENU: $0800 - $20D9 ($18DA)
Source: C:\jac\system\Java\Programming\Workspaces\Productions\com.wudsn.productions.atari800.thecartstudio\asm\thecart-menu\CartMenu-Extended.asm
   369
   370 					org menu_main_ram+$5fff
   371 67FF 00				.byte 0
   372
   373 				;===============================================================
   374
   375 					opt f-				;Extended Menu Data, 40k, bank 11
   376 					org $0000
   377 					opt f+
   378
   379 					org $9fff
   380 9FFF 00				.byte 0
   381
   382 				;===============================================================
   383
   384
